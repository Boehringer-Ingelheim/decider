% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim_jointBLRM.R
\name{sim_jointBLRM}
\alias{sim_jointBLRM}
\title{Simulate dose-finding trials}
\usage{
sim_jointBLRM(
   active.mono1.a = FALSE,
   active.mono1.b = FALSE,
   active.mono2.a = FALSE,
   active.mono2.b = FALSE,
   active.combi.a = FALSE,
   active.combi.b = FALSE,
   doses.mono1.a,
   doses.mono2.a,
   doses.mono1.b,
   doses.mono2.b,
   doses.combi.a,
   doses.combi.b,
   dose.ref1,
   dose.ref2,
   tox.mono1.a,
   tox.mono2.a,
   tox.combi.a,
   tox.mono1.b,
   tox.mono2.b,
   tox.combi.b,
   start.dose.mono1.a,
   start.dose.mono2.a,
   start.dose.mono1.b,
   start.dose.mono2.b,
   start.dose.combi.a1,
   start.dose.combi.a2,
   start.dose.combi.b1,
   start.dose.combi.b2,
   cohort.queue = rep( c(1,2,3,4,5,6), times= 100),
   historical.data = NULL,
   esc.rule = "ewoc",
   esc.comp.max=1,
   dosing.intervals = c(0.16, 0.33, 0.6),
   ewoc.threshold = 0.25,
   loss.weights = c(1, 0, 1, 2),
   dynamic.weights =  rbind(
       c(0.32, 0, 0.32, 0.36),
       c(0.29, 0, 0.31, 0.40),
       c(0.27, 0, 0.33, 0.40),
       c(0.20, 0, 0.30, 0.50)),
   prior.mu = list(
       mu_a1 = c(logit(0.33), 2),
       mu_b1 = c(0, 1),
       mu_a2 = c(logit(0.33), 2),
       mu_b2 = c(0, 1),
       mu_eta = c(0, 1.121)),
   prior.tau = list(
       tau_a1 = c(log(0.25), log(4)/1.96),
       tau_b1 = c(log(0.125), log(4)/1.96),
       tau_a2 = c(log(0.25), log(4)/1.96),
       tau_b2 = c(log(0.125), log(4)/1.96),
       tau_eta = c(log(0.125),log(4)/1.96)),
   saturating = FALSE,
   esc.step = NULL,
   esc.step.mono1.a = esc.step,
   esc.step.mono2.a = esc.step,
   esc.step.mono1.b = esc.step,
   esc.step.mono2.b = esc.step,
   esc.step.combi.a1 = esc.step,
   esc.step.combi.b1 = esc.step,
   esc.step.combi.a2 = esc.step,
   esc.step.combi.b2 = esc.step,
   esc.constrain = FALSE,
   esc.constrain.mono1.a=esc.constrain,
   esc.constrain.mono2.a=esc.constrain,
   esc.constrain.mono1.b=esc.constrain,
   esc.constrain.mono2.b=esc.constrain,
   esc.constrain.combi.a1=esc.constrain,
   esc.constrain.combi.b1=esc.constrain,
   esc.constrain.combi.a2=esc.constrain,
   esc.constrain.combi.b2=esc.constrain,
   cohort.size = c(3),
   cohort.size.mono1.a = cohort.size,
   cohort.size.mono1.b = cohort.size,
   cohort.size.mono2.a = cohort.size,
   cohort.size.mono2.b = cohort.size,
   cohort.size.combi.a = cohort.size,
   cohort.size.combi.b = cohort.size,
   cohort.prob = NULL,
   cohort.prob.mono1.a = cohort.prob,
   cohort.prob.mono1.b = cohort.prob,
   cohort.prob.mono2.a = cohort.prob,
   cohort.prob.mono2.b = cohort.prob,
   cohort.prob.combi.a = cohort.prob,
   cohort.prob.combi.b = cohort.prob,
   max.n = 42,
   max.n.mono1.a = max.n,
   max.n.mono1.b = max.n,
   max.n.mono2.a = max.n,
   max.n.mono2.b = max.n,
   max.n.combi.a = max.n,
   max.n.combi.b = max.n,
   mtd.decision = list(
       target.prob = 0.5,
       pat.at.mtd = 6,
       min.pat = 12,
       min.dlt = 1,
       rule = 2),
   mtd.decision.combi.a = mtd.decision,
   mtd.decision.combi.b = mtd.decision,
   mtd.decision.mono1.a = mtd.decision,
   mtd.decision.mono1.b = mtd.decision,
   mtd.decision.mono2.a = mtd.decision,
   mtd.decision.mono2.b = mtd.decision,
   mtd.enforce = FALSE,
   mtd.enforce.mono1.a = mtd.enforce,
   mtd.enforce.mono2.a = mtd.enforce,
   mtd.enforce.mono1.b = mtd.enforce,
   mtd.enforce.mono2.b = mtd.enforce,
   mtd.enforce.combi.a = mtd.enforce,
   mtd.enforce.combi.b = mtd.enforce,
   backfill.mono1.a = FALSE,
   backfill.mono1.b = FALSE,
   backfill.mono2.a = FALSE,
   backfill.mono2.b = FALSE,
   backfill.combi.a = FALSE,
   backfill.combi.b = FALSE,
   backfill.size = c(3),
   backfill.prob = NULL,
   backfill.size.mono1.a = backfill.size,
   backfill.size.mono1.b = backfill.size,
   backfill.size.mono2.a = backfill.size,
   backfill.size.mono2.b = backfill.size,
   backfill.size.combi.a = backfill.size,
   backfill.size.combi.b = backfill.size,
   backfill.prob.mono1.a = backfill.prob,
   backfill.prob.mono1.b = backfill.prob,
   backfill.prob.mono2.a = backfill.prob,
   backfill.prob.mono2.b = backfill.prob,
   backfill.prob.combi.a = backfill.prob,
   backfill.prob.combi.b = backfill.prob,
   backfill.start.mono1.a = NULL,
   backfill.start.mono1.b = NULL,
   backfill.start.mono2.a = NULL,
   backfill.start.mono2.b = NULL,
   backfill.start.combi.a1 = NULL,
   backfill.start.combi.a2 = NULL,
   backfill.start.combi.b1 = NULL,
   backfill.start.combi.b2 = NULL,
   n.studies = 1,
   n.cores = 1,
   seed = sample.int(.Machine$integer.max, 1),
   chains = 4,
   iter = 13500,
   warmup = 1000,
   adapt_delta = 0.8,
   max_treedepth = 15,
   refresh=0,
   file.name = NULL,
   path = NULL,
   monitor.path = NULL,
   working.path = NULL,
   clean.working.path = FALSE,
   output.sim.config =TRUE
)
}
\arguments{
\item{active.mono1.a, active.mono1.b, active.mono2.a, active.mono2.b, active.combi.a, active.combi.b}{Logicals, default to \code{FALSE}. Each parameter activates the simulation of the
corresponding trial. If the parameter is \code{FALSE}, the corresponding trial is not simulated, all parameters with this suffix are ignored, and no historical information can be included for this trial.}

\item{doses.mono1.a, doses.mono1.b, doses.mono2.a, doses.mono2.b}{Numericals, one dimensional vectors with positive, strictly ascending entries. Each vector indicates the dose levels for the corresponding monotherapy trial.
Optional if \code{active.[...]} is \code{FALSE} for the corresponding suffix.}

\item{doses.combi.a, doses.combi.b}{Numericals, two dimensional arrays with two rows, arbitrarily many columns, and positive entries. Does not need to be ascending. Each column indicates a combination dose level for the corresponding combination therapy trial,
where the entry in the first row of a specific column gives the dose level of compound 1, and the entry in the second row the dose level of compound 2. Optional if \code{active.combi.[...]} is \code{FALSE} for the corresponding suffix.}

\item{dose.ref1}{Positive numerical value. Reference dose of compound 1.}

\item{dose.ref2}{Positive numerical value. Reference dose of compound 2.}

\item{tox.mono1.a, tox.mono1.b, tox.mono2.a, tox.mono2.b}{Numericals, one dimensional vectors with entries in \eqn{(0,1)}.  Optional if \code{active.mono.[...]} is \code{FALSE} for the corresponding suffix. Otherwise,
must have the same length as \code{doses.[...]} for the corresponding suffix. The entry \eqn{i} specifies the DLT rate of dose \eqn{i} of the corresponding trial.}

\item{tox.combi.a, tox.combi.b}{Numericals, one dimensional vectors with entries in \eqn{(0,1)}.  Optional if \code{active.combi.[...]} is \code{FALSE} for the corresponding suffix. Otherwise,
its length must equal the number of columns of \code{doses.combi.[...]}. The entry \eqn{i} specifies the DLT rate of the dose combination of row \eqn{i} of \code{doses.combi.[...]}.}

\item{start.dose.mono1.a, start.dose.mono2.a, start.dose.mono1.b, start.dose.mono2.b}{Positive numerical values that specify the starting dose for the simulated monotherapy trials.
The value of \code{start.dose.mono.[...]} must be one of the entries of \code{doses.mono.[...]} for the corresponding suffix. The starting doses are optional if the corresponding trial is not activated.}

\item{start.dose.combi.a1, start.dose.combi.a2, start.dose.combi.b1, start.dose.combi.b2}{Positive numerical values that specify the starting dose for the simulated combination therapy trials.
The values with suffixes \code{.a1} and  \code{.a2} define the starting dose for first and second compound of the \code{combi.a} trial, and must appear as combination in one of the columns of \code{doses.combi.a}. The same applies for the trial with suffix \code{combi.b}. The starting doses are optional if the corresponding trial is not activated.}

\item{cohort.queue}{Optional numerical or character vector that specifies the order or pattern in which cohorts are enrolled in the simulated trials. By default, cohorts are enrolled sequentially in the order:
\code{mono1.a}, \code{mono2.a}, \code{combi.a}, \code{mono1.b}, \code{mono2.b}, \code{combi.b}, which is repeated until all trials concluded.
In general, entry \eqn{i} specifies to which simulated trial the \eqn{i}th simulated cohort is enrolled (provided that this trial has not concluded yet, in which case the entry would be ignored).
The \code{cohort.queue} can therefore be used to express e.g. that a certain number of monotherapy cohorts are completed prior to the start of a combination therapy trial.
The \code{cohort.queue} can either be a short pattern that is repeated automatically, or alternatively a long vector
that contains already the order of all cohorts that may occur in the trial. The latter can e.g. be used to ensure that a trial
has concluded prior to the start of some other trial by supplying enough cohorts to the former to reach its maximum sample size before the first
cohort for the latter trial is enrolled.

The trials to which cohorts are assigned are encoded as follows:
\itemize{
\item{\code{"mono1.a"} or \code{1}\cr Corresponds to a cohort for the \code{mono1.a} trial (monotherapy trial for compound 1).}
\item{\code{"mono2.a"} or \code{2}\cr Corresponds to a cohort for the \code{mono2.a} trial (monotherapy trial for compound 2).}
\item{\code{"combi.a"} or \code{3}\cr Corresponds to a cohort for the \code{combi.a} trial (combination therapy trial).}
\item{\code{"mono1.b"} or \code{4}\cr Corresponds to a cohort for the \code{mono1.b} trial (monotherapy trial for compound 1).}
\item{\code{"mono2.b"} or \code{5}\cr Corresponds to a cohort for the \code{mono2.b} trial (monotherapy trial for compound 2).}
\item{\code{"combi.b"} or \code{6}\cr Corresponds to a cohort for the \code{combi.b} trial (combination therapy trial).}
}
Assuming that each cohort is assigned to the minimal possible cohort size (specified via the argument \code{cohort.size}),
the \code{cohort.queue} should contain sufficiently many entries for each activated trial so that it can in principle reach the
specified maximum patient number to be enrolled in the trial. For instance, if cohorts consist of 3 or more patients and the maximum sample size
(given in \code{max.n.[...]}) of this trial is 30, than the trial should appear at least 10 times in the cohort queue. If this
is not the case, the function will repeat the cohort queue until sufficiently many cohorts are contained.}

\item{historical.data}{Optional parameter that must be \code{NULL} (the default) or a named list that specifies the historical data to be included in the trial.
Historical data can be included from both purely historical trials (i.e., not actively simulated) and also directly to one of the
simulated trials (in which case the simulation assumes that this data was previously recorded in the corresponding trial).

A value of \code{NULL} represents that no historical data is available. Otherwise, the historical data is specified via the named list entries \code{dose1}, \code{dose2}, \code{n.pat}, \code{n.dlt}, and \code{trial}
(where the names are not case-sensitive). The list entries should be vectors whose length is equal to the number of historical cohorts to be included.
Their format should be as follows:
\itemize{
\item{\code{historical.data$dose1}\cr Numerical vector with non-negative or \code{NA} entries. Entry \eqn{i} gives the dose level of compound 1 that was administered to the \eqn{i}th
historical cohort. If compound 1 was not administered to this cohort, the entry should be \code{0} or \code{NA}.}
\item{\code{historical.data$dose2}\cr Numerical vector with non-negative or \code{NA} entries. Entry \eqn{i} gives the dose level of compound 2 that was administered to the \eqn{i}th
historical cohort. If compound 2 was not administered to this cohort, the entry should be \code{0} or \code{NA}.}
\item{\code{historical.data$n.pat}\cr Numerical vector with non-negative entries. Entry \eqn{i} gives the number of patients of the \eqn{i}th
historical cohort. If the patient number is \code{0}, the historical cohort is removed automatically. \code{NA} entries are not permitted.}
\item{\code{historical.data$n.dlt}\cr Numerical vector with non-negative entries. Entry \eqn{i} gives the number of patients that experienced DLT among the \eqn{i}th
historical cohort. The number of DLTs is not allowed be larger than the number of patients in the cohort. \code{NA} entries are not permitted.}
\item{\code{historical.data$trial}\cr Numerical or character vector with arbitrary entries (except for \code{NA}
which is not permitted). Entry \eqn{i} gives the code for the trial from which the \eqn{i}th
historical cohort arises. That is, historical patients are grouped in different historical or concurrent trials according to these values,
where the entries are not case sensitive and do not differentiate between numbers and the converted strings (i.e., \code{42} and \code{"42"} represent the same trial).
The following entries are reserved to represent that the cohort belongs to one of the actively simulated trials:
\itemize{
\item{\code{"mono1.a"} or \code{1}\cr The cohort is assumed to belong to the actively simulated trial \code{mono1.a}.}
\item{\code{"mono2.a"} or \code{2}\cr The cohort is assumed to belong to the actively simulated trial \code{mono2.a}.}
\item{\code{"combi.a"} or \code{3}\cr The cohort is assumed to belong to the actively simulated trial \code{combi.a}.}
\item{\code{"mono1.b"} or \code{4}\cr The cohort is assumed to belong to the actively simulated trial \code{mono1.b}.}
\item{\code{"mono2.b"} or \code{5}\cr The cohort is assumed to belong to the actively simulated trial \code{mono2.b}.}
\item{\code{"combi.b"} or \code{6}\cr The cohort is assumed to belong to the actively simulated trial \code{combi.b}.}
}

All other strings or numbers are interpreted to belong to purely historical (already completed) trials.
If data for the actively simulated trials are included, the corresponding trial must be activated (otherwise, the reserved
trial codes are not permitted), and the historical cohorts must match the type of the trial. The latter means that historical
data for e.g. the \code{mono1.a} trial must contain observations from monotherapy with compound 1.}
}}

\item{esc.rule}{Optional character string, must have one of the following values: \code{"ewoc"}, \code{"ewoc.opt"}, \code{"ewoc.max"},
\code{"loss"}, \code{"dynamic"}, or \code{"dynamic.loss"}, where the default is \code{"ewoc"}. The value of \code{esc.rule}
specifies which escalation rule is applied during the simulation, cf. Details. The character strings are
interpreted in a case-insensitive fashion. The possible values are interpreted as follows:
\itemize{
\item{\code{"ewoc"} or \code{"ewoc.opt"}\cr Applies the EWOC criterion with optimal probability rule and three dosing intervals (underdosing, target dosing, and overdosing). That is, the next dose is
the one with the largest probability that the true DLT rate lies in the target interval
among the doses whose probability of having a DLT rate in the overdosing interval is lower than the feasibility bound specified in the argument \code{ewoc.threshold}. If multiple doses or
dose combinations attain the maximum target probability and satisfy the EWOC principle, the escalation rule will additionally maximize the dose level of the compound that is
specified in the argument \code{esc.comp.max}.}
\item{\code{"ewoc.max"}\cr Applies the EWOC criterion with maximum dose rule and three dosing intervals (underdosing, target dosing, and overdosing). That is, the next dose is the largest one
among the doses whose probability of having true DLT rate in the overdosing interval is lower than the feasibility bound specified in the argument \code{ewoc.threshold}. For dose combinations,
the escalation rule will first maximize the compound specified in \code{esc.comp.max}, and afterwards the other compound.}
\item{\code{"loss"}\cr Applies the static loss escalation rule using the weights specified in the argument \code{loss.weights} and four dosing intervals
(under dosing, target dosing, excessive toxicity, and unacceptable toxicity). When multiple dose combinations
result in the same expected loss (Bayes risk), the function will additionally maximize the compound specified in the argument \code{esc.comp.max}
among the doses with minimum expected loss.}
\item{\code{"dynamic"} or \code{"dynamic.loss"}\cr Applies the dynamic loss escalation rule using the weights specified in the argument \code{dynamic.weights} and four dosing intervals
(under dosing, target dosing, excessive toxicity, and unacceptable toxicity). When multiple dose combinations
result in the same expected loss (Bayes risk), the function will additionally maximize the compound specified in the argument \code{esc.comp.max}
among the doses with minimum expected loss.}
}}

\item{esc.comp.max}{Optional integer, must be either \code{1} (the default) or \code{2}. The value specifies which compound (1 or 2) is maximized first when an escalation rule
leads to a draw among multiple dose combinations.}

\item{dosing.intervals}{Optional numeric vector with ascending entries between 0 and 1. The argument \code{dosing.intervals} must be of length 1, 2, or 3, and defines the boundaries
of the dosing intervals used for escalation decisions. The default is \code{c(0.16, 0.33, 0.6)} which can be used for any escalation rule. The interpretation and requirements vary slightly across different escalation rules (different values of \code{esc.rule}).

More precisely, the following cases are differentiated. If \code{esc.rule} is...
\itemize{
\item{\code{"ewoc"},\code{"ewoc.max"}, or \code{"ewoc.opt"}\cr The length can be either 1, 2, or 3. In the latter two cases,
only the first two entries are used to specify the targeted dosing interval. That is, the target interval is
assumed to range from \code{dosing.intervals[1]} to \code{dosing.intervals[2]}, while a potential third entry is discarded.
If \code{dosing.intervals} has length 1 and value \code{x}, the argument is internally transformed to \code{c(0, x)}. That is,
the target interval is assumed to range from \code{0} to \code{x}, while the underdosing interval is not considered.\cr
The overdosing interval is implicitly defined to range from \code{dosing.intervals[2]} to \code{1}, while the underdosing
interval is defined to range from \code{0} to \code{dosing.intervals[1]}.}
\item{\code{"loss"},\code{"dynamic.loss"}, or \code{"dynamic"}\cr Must have three entries which are used to specify the targeted dosing interval and the interval for excessively toxic dosing.
That is, the target interval is assumed to range from \code{dosing.intervals[1]} to \code{dosing.intervals[2]}, while the interval
for excessively toxic dosing is assumed to range from \code{dosing.intervals[2]} to \code{dosing.intervals[3]}. The underdosing interval is
therefore implicitly defined to range from  \code{0} to \code{dosing.intervals[1]}, while the unacceptably toxic dosing interval is implicitly defined
to range from \code{dosing.intervals[3]} to \code{1}.}
}}

\item{ewoc.threshold}{Optional numerical value between 0 and 1 (excluding the boundaries), defaults to \code{0.25}. Defines the feasibility bound for the EWOC criterion,
i.e., when \code{esc.rule} is one of the EWOC-based rules, the next dose must have a probability of having DLT rate in the overdosing interval lower than \code{ewoc.threshold}.
The value is ignored when \code{esc.rule} specifies one of the loss-based escalation rules.}

\item{loss.weights}{Optional numerical vector with four entries (which can be arbitrary numbers), the default is \code{c(1,0,1,2)}. Specifies the interval weights/penalties
that are used for static loss escalation. This is only needed when \code{esc.rule} is \code{"loss"}, and the parameter is ignored otherwise.
More precisely, \code{loss.weights[1]} is the weight of the underdosing interval, \code{loss.weights[2]} the weight of the  target dosing interval,
\code{loss.weights[3]} the weight of the excessively toxic dosing interval, and \code{loss.weights[4]} is the weight of the unacceptably toxic dosing interval.
See the Details section below for explanations regarding the methodology.}

\item{dynamic.weights}{Optional numerical matrix with four rows and four columns, and arbitrary numbers as entries.  Specifies the interval weights/penalties
that are used for dynamic loss escalation. This is only needed when \code{esc.rule} is \code{"dynamic"} or \code{"dynamic.loss"}, and the parameter is ignored otherwise.
Each row of \code{dynamic.weights} specifies one of the static loss weight vectors that are interpolated during dynamic loss escalation. See the Details section below for explanations regarding the methodology.

More precisely, \code{dynamic.weights[1, ]} is the static weight vector that is weighted by the posterior probability that the reference dose has true DLT rate in the underdose interval,
\code{dynamic.weights[2, ]} is the static weight vector that is weighted by the posterior probability that the reference dose has true DLT rate in the target interval,
\code{dynamic.weights[3, ]} is the static weight vector that is weighted by the posterior probability that the reference dose has true DLT rate in the excessively toxic dosing interval, and
\code{dynamic.weights[4, ]} is the static weight vector that is weighted by the posterior probability that the reference dose has true DLT rate in the unacceptably toxic dosing interval.
The default value for \code{dynamic.weights} is a matrix with the following four rows (in order):
\itemize{
\item{\code{c(0.32, 0, 0.32, 0.36)},}
\item{\code{c(0.29, 0, 0.31, 0.40)},}
\item{\code{c(0.27, 0, 0.33, 0.40)},}
\item{\code{c(0.20, 0, 0.30, 0.50)}.}
}}

\item{prior.mu}{Optional list that gives the prior distribution for the hyper means \eqn{\mu}. The list must
have named entries, which all need to be numeric vectors of length 2:
\itemize{
\item{\code{prior.mu$mu_a1}\cr Numeric with length two, defaults to \code{c(logit(0.33), 2)}. Specifies mean and SD of the hypermean \eqn{\mu_1} of the parameter \eqn{log(\alpha_1)} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
\item{\code{prior.mu$mu_b1}\cr Numeric with length two, defaults to \code{c(0, 1)}. Specifies mean and SD of the hypermean \eqn{\mu_2} of the parameter \eqn{log(\beta_1)} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
\item{\code{prior.mu$mu_a2}\cr Numeric with length two, defaults to \code{c(logit(0.33), 2)}. Specifies mean and SD of the hypermean \eqn{\mu_3} of the parameter \eqn{log(\alpha_2)} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
\item{\code{prior.mu$mu_b2}\cr Numeric with length two, defaults to \code{c(0, 1)}. Specifies mean and SD of the hypermean \eqn{\mu_4} of the parameter \eqn{log(\beta_2)} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
\item{\code{prior.mu$mu_eta}\cr Numeric with length two, defaults to \code{c(0, 1.121)}. Specifies mean and SD of the hypermean \eqn{\mu_5} of the parameter \eqn{\eta} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
}}

\item{prior.tau}{Optional list that gives the prior distribution for the between-trial heterogeneities (hyper SD) \eqn{\tau}. The list must
have named entries, which all need to be numeric vectors of length 2:
\itemize{
\item{\code{prior.tau$tau_a1}\cr Numeric with length two, defaults to \code{c(log(0.25), log(2)/1.96)}. Specifies mean and SD on log-scale of the heterogeneity \eqn{\tau_1} of the parameter \eqn{log(\alpha_1)} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
\item{\code{prior.tau$tau_b1}\cr Numeric with length two, defaults to \code{c(log(0.125), log(2)/1.96)}. Specifies mean and SD on log-scale of the heterogeneity \eqn{\tau_2} of the parameter \eqn{log(\beta_1)} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
\item{\code{prior.tau$tau_a2}\cr Numeric with length two, defaults to \code{c(log(0.25), log(2)/1.96)}. Specifies mean and SD on log-scale of the heterogeneity \eqn{\tau_3} of the parameter \eqn{log(\alpha_2)} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
\item{\code{prior.tau$tau_b2}\cr Numeric with length two, defaults to \code{c(log(0.125), log(2)/1.96)}. Specifies mean and SD on log-scale of the heterogeneity \eqn{\tau_4} of the parameter \eqn{log(\beta_2)} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
\item{\code{prior.tau$tau_eta}\cr Numeric with length two, defaults to \code{c(log(0.125), log(2)/1.96)}. Specifies mean and SD on log-scale of the heterogeneity \eqn{\tau_5} of the parameter \eqn{\eta} in the BLRM. The second entry must
therefore be positive. See the Details section below for more detail.}
}}

\item{saturating}{Optional logical, defaults to \code{FALSE}. If \code{TRUE}, the BLRM will be using a saturating interaction term as described in
\code{\link[OncoBayes2:blrm_formula_saturating]{OncoBayes2::blrm_formula_saturating}()}. Also refer to the Details section in the documentation
of \code{\link[OncoBLRM:scenario_jointBLRM]{scenario_jointBLRM}()}.}

\item{esc.step, esc.step.mono1.a, esc.step.mono2.a, esc.step.combi.a1, esc.step.combi.a2}{Optional numerical values that specify
the maximum factor of dose escalations that is demanded additionally to the selected escalation rule. The default is \code{NULL}, in which case the escalation step
is determined automatically for the corresponding trial (if activated) as the maximum factor between the (sorted) available doses for the trial.
As an example, an value of \code{esc.step=2} indicates that the dose can at most be doubled, or, in other words, that the increment between subsequent dose
levels is at most 100\%.

The argument \code{esc.step} is a global variant, all escalation steps that were not specified by the user default to its value. In particular, if all trials shall use the same escalation factor,
only the value of \code{esc.step} needs to be defined, while the trial-specific variants can be used to express that a specific trial shall deviate from
the global parameter. Note that consistency checks are performed for these parameters, i.e., whether the specified escalation step allows to reach all available doses.

The value of \code{esc.step.[...]} gives the escalation step that is used for the corresponding trial. Note that there are two escalation steps for combination therapy trials:
For instance, \code{esc.step.combi.a1} gives the maximum escalation factor in the first compound during combination therapy escalations, while
\code{esc.step.combi.a2} defines the escalation step for the second compound.}

\item{esc.step.mono1.b, esc.step.mono2.b, esc.step.combi.b1, esc.step.combi.b2}{Same as \code{esc.step.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{esc.constrain, esc.constrain.mono1.a, esc.constrain.mono2.a}{Optional logicals, default to \code{FALSE}. When \code{TRUE}, escalation decisions in the corresponding trial
are constrained to the available dose levels, in the sense that only the next larger dose can be used for
the next cohort. This does not apply to de-escalation, where arbitrary lower dose levels are allowed.
Note that \code{esc.constrain[...]} overrules \code{esc.step[...]}, so that the given
escalation step is ignored when \code{esc.constrain[...]} is \code{TRUE}.

As before, \code{esc.contrain} is the global variant and affects all trials. If a specific trial
shall deviate from the global setting, this needs to be activated specifically with
the trial specific variant \code{esc.constrain.[...]} using the corresponding suffix.}

\item{esc.constrain.mono1.b, esc.constrain.mono2.b, esc.constrain.combi.b1, esc.constrain.combi.b2}{Same as \code{esc.constrain.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{esc.constrain.combi.a1, esc.constrain.combi.a2}{Optional logicals, default to \code{FALSE}. Work in the same way as \code{esc.constrain.mono[...]},
except that the compounds in a combination therapy trial are constrained separately from each other, where
e.g. \code{esc.constrain.combi.a1} affects compound 1, while  \code{esc.constrain.combi.a2} affects
compound 2. For instance, it is possible to activate the restriction to the next larger dose level only
for the first compound, and still use an escalation step for the second compound.}

\item{cohort.size, cohort.size.mono1.a, cohort.size.mono2.a, cohort.size.combi.a}{Optional positive integer vectors that specify the available cohort sizes for simulated cohorts. The global variant, \code{cohort.size}, defaults to \code{3} (i.e., all cohorts will contain 3 patients),
the remaining trial-specific parameters default to the value of \code{cohort.size}. In particular, if all trials shall use the same cohort sizes,
only the value of \code{cohort.size} needs to be defined, while the trial-specific variants can be used to express that a specific trial shall deviate from
the global parameter.

The \code{cohort.size} can either be a single value (all cohorts use the same size) or a vector of integers that give the available cohort sizes. In the latter case,
the simulated cohort sizes are drawn at random from the possible cohort sizes using the probability for each cohort size that is specified in \code{cohort.prob}.
As before, the trial-specific variant, \code{cohort.size.[...]}, only affect the corresponding trial.}

\item{cohort.size.mono1.b, cohort.size.mono2.b, cohort.size.combi.b}{Same as \code{cohort.size.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{cohort.prob, cohort.prob.mono1.a, cohort.prob.mono2.a, cohort.prob.combi.a}{Optional positive numeric vectors with values between 0 and 1 that specify the probability for each of the available cohort sizes in the corresponding argument \code{cohort.size.[...]}. The global variant, \code{cohort.prob}, defaults to \code{NULL},
the remaining trial-specific parameters default to the value of \code{cohort.prob}. If the parameter is \code{NULL} for a trial,
the function will assign the same probability to each entry of \code{cohort.size}, i.e., the cohort size is chosen uniformly at random from
the provided possible cohort sizes.
If all trials shall use the same probabilities for selecting the cohort size,
only the value of \code{cohort.prob} needs to be defined, while the trial-specific variants can be used to express that a specific trial shall deviate from
the global parameter.

Each of the arguments \code{cohort.prob.[...]} must be \code{NULL} or a vector of the same length as the argument \code{cohort.size.[...]}, where the lengths and contents may
differ across different trials/suffixes.}

\item{cohort.prob.mono1.b, cohort.prob.mono2.b, cohort.prob.combi.b}{Same as \code{cohort.prob.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{max.n, max.n.mono1.a, max.n.mono2.a, max.n.combi.a}{Optional positive integer values that specify
the maximum number of patients to be enrolled in simulated trials. If the simulated number of patients in a trial equals or surpasses the specified number in \code{max.n.[...]} and
has not stopped prematurely and not determined an MTD yet, the simulated trial is stopped without declaring an MTD due to reaching the maximum sample size.

The global variant of the parameter, \code{max.n}, defaults to 42 (i.e., MTD must be reached after 14 cohorts when the default values for \code{cohort.size} and \code{cohort.prob} are used).
The trial-specific parameters, \code{max.n.[...]}, default to the global value \code{max.n} and only need to be adjusted if the corresponding trial shall deviate from the
global value.}

\item{max.n.mono1.b, max.n.mono2.b, max.n.combi.b}{Same as \code{max.n.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{mtd.decision, mtd.decision.mono1.a, mtd.decision.mono2.a, mtd.decision.combi.a}{Optional named lists that specify the rules for MTD selection. The determination of the MTD may occur independently for each simulated trial as soon as the conditions that
are specified in the corresponding \code{mtd.decision[...]} are met. Each list must have five named entries, namely, \code{target.prob}, \code{pat.at.mtd}, \code{min.pat}, \code{min.dlt}, and \code{rule}.
The names of the list entries are not case sensitive. For the actual MTD selection, the function will always first demand that the current dose level of the current trial
is recommended again, i.e. is also the recommended dose for the next cohort in this trial (the so-called stabilization criterion). If this is the case,
the conditions specified in the corresponding \code{mtd.decision[...]} are checked. If these conditions are also satisfied, the function will declare the current dose
of this trial to be the MTD and will not simulate any further cohorts for this trial.

The entries are single numerical values with the following specifications and interpretations.
\itemize{
\item{\code{mtd.decision[...]$rule}\cr Integer, can only be \code{1} or \code{2} (the latter is the default). Specifies which of the remaining entries of \code{mtd.decision[...]} are used as mandatory conditions for MTD selection. For both rules,
two conditions are demanded as necessary conditions, while only one of the remaining two conditions must hold. The precise specifications are:
\itemize{
\item{\code{mtd.decision[...]$rule=1}\cr The conditions posed by the entries \code{mtd.decision[...]$pat.at.mtd} and \code{mtd.decision[...]$min.dlt} are mandatory, while only one of the conditions that are
posed by \code{mtd.decision[...]$min.pat} and \code{mtd.decision[...]$target.prob} must hold.}
\item{\code{mtd.decision[...]$rule=2}\cr The conditions from \code{mtd.decision[...]$min.pat} and \code{mtd.decision[...]$min.dlt} are mandatory, while only one of the conditions that are
posed by \code{mtd.decision[...]$pat.at.mtd} and \code{mtd.decision[...]$target.prob} must hold.}
}
}
\item{\code{mtd.decision[...]$min.pat}\cr Non-negative integer, defaults to \code{12}. Specifies the minimum number of patients that need to have been enrolled in a trial before the MTD can be declared.}
\item{\code{mtd.decision[...]$pat.at.mtd}\cr Non-negative integer, defaults to \code{6}. Specifies the minimum number of patients that need to have been treated with the current dose
(i.e., the current candidate for MTD determination) before the MTD can be declared.}
\item{\code{mtd.decision[...]$min.dlt}\cr Non-negative integer, defaults to \code{1}. Specifies the minimum number of DLTs that need to have been observed in a trial before the MTD can be declared.}
\item{\code{mtd.decision[...]$target.prob}\cr Non-negative real number strictly smaller than 1, defaults to \code{0.5}. Specifies a minimum probability
of having true DLT rate in the target interval that needs to be reached by the dose that is
to be declared the MTD. Note that this condition is always one of the two optional conditions, i.e., in case of the first rule, the condition does not need to hold
when sufficiently many patients were enrolled in total, while in case of the second rule, the condition does not need to hold when sufficiently many patients
were enrolled at the MTD.}
}
As before, the global parameter \code{mtd.decision} can be used to select a rule that is used for all simulated trials.
The trial-specific parameters, \code{mtd.decision.[...]}, default to the global value and can be adjusted to use different, trial-specific decision rules
for some or all of the trials.}

\item{mtd.decision.mono1.b, mtd.decision.mono2.b, mtd.decision.combi.b}{Same as \code{mtd.decision.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{mtd.enforce, mtd.enforce.mono1.a, mtd.enforce.mono2.a, mtd.enforce.combi.a}{Optional logicals, default to \code{FALSE}. These parameters indicate whether the declaration of the MTD should be enforced once the maximum number
of patients is reached and the trial was not stopped yet. That is, if the parameter \code{mtd.enforce.[...]} for a specific trial is \code{TRUE},
the function will declare the next recommended dose as MTD once the maximum number of patients (\code{max.n.[...]}) was reached (provided that
the trial was not stopped early or found the MTD before reaching the maximum sample size). In particular,
these trials are not counted to belong to the category of trials that reached the maximum sample size without declaring an MTD. Further,
note that the value of \code{mtd.decision.[...]$min} can be set to a value greater than the maximum sample size, which would result in
only declaring an MTD if the maximum sample size is reached, but not at earlier points (as the condition on the minimal patient number could
not be fulfilled then).

As before, there is a global variant of this parameter, namely \code{mtd.enforce}, which can be used to set this option for all trials at once.
To set the escalation rule only for a specific trial, use the trial-specific variants \code{mtd.enforce.[...]} with the corresponding suffix.}

\item{mtd.enforce.mono1.b, mtd.enforce.mono2.b, mtd.enforce.combi.b}{Same as \code{mtd.enforce.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{backfill.mono1.a, backfill.mono2.a, backfill.combi.a}{Optional logicals, indicating whether back-fill cohorts are simulated for the trial.}

\item{backfill.mono1.b, backfill.mono2.b, backfill.combi.b}{Same as \code{backfill.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{backfill.size, backfill.size.mono1.a, backfill.size.mono2.a, backfill.size.combi.a}{Optional numericals, provide the size of simulated back-fill cohorts. Interpreted in the same fashion as \code{cohort.size}.}

\item{backfill.prob, backfill.prob.mono1.a, backfill.prob.mono2.a, backfill.prob.combi.a}{Optional numericals, provide the probabilities if multiple possible back-fill cohort sizes are given.
Interpreted in the same fashion as \code{cohort.prob}.}

\item{backfill.size.mono1.b, backfill.size.mono2.b, backfill.size.combi.b}{Same as \code{backfill.size.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{backfill.prob.mono1.b, backfill.prob.mono2.b, backfill.prob.combi.b}{Same as \code{backfill.prob.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{backfill.start.mono1.a, backfill.start.mono2.a, backfill.start.combi.a1, backfill.start.combi.a2}{Optional numericals. Specify the first dose on which back-fill cohorts are enrolled. If not provided, the
lowest available dose will be assumed to be the starting point of back-fill cohorts in the respective trial.}

\item{backfill.start.mono1.b, backfill.start.mono2.b, backfill.start.combi.b1, backfill.start.combi.b2}{Same as \code{backfill.start.[...].a} (where \code{[...]} is \code{mono1}, \code{mono2}, or \code{combi})
but for the second potentially simulated trial (suffix \code{.b}) of the respective trial type.}

\item{n.studies}{Positive integer that specifies the number of studies to be simulated, defaults to \code{1}. Due to the long simulation time, it is recommended
to first try lower numbers to obtain an estimation of the run-time for larger numbers of studies. Typically, about 1000 studies are recommended to obtain
acceptably accurate simulation results.}

\item{n.cores}{Optional positive integer, defaults to \code{1}. Enables parallelized simulation and specifies the number of cores to be used. If a value greater
than 1 is given, the function will process the simulations in parallel using the given number of cores.}

\item{seed}{Optional positive integer that specified the seed to be used for the simulation. The default is \code{sample.int(.Machine$integer.max, 1)}.
Note that reproducibility can only be obtained when the function is executed on exactly the same computing architecture, using identical software versions
(e.g. of the compiler, Stan, and R), and the same input specifications. This is due to the internal use of \code{\link[rstan:rstan]{rstan-package}} for MCMC sampling, which is
only reproducible under these restrictions (refer to the Stan reference manual from \code{\link[rstan:rstan]{rstan-package}}'s \href{https://mc-stan.org}{homepage} for more detail).}

\item{chains}{Optional positive integer that specifies the number of Markov chains to be used during MCMC sampling, defaults to \code{4}. The parameter is given to the method
\code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()} from the package \code{\link[rstan:rstan]{rstan-package}}.}

\item{iter}{Optional positive integer that specifies the total number of iterations per chain to be used during MCMC sampling, defaults to \code{6000}. The parameter is given to the method
\code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()} from the package \code{\link[rstan:rstan]{rstan-package}}. Be aware that the first \code{warmup} iterations among the \code{iter}-many samples are discarded.
The function enforces \code{iter} to be at least \code{2000}, and further that \code{iter} is larger or equal than \code{warmup + 1000} (to ensure
that at least 1000 samples from each chain are kept).}

\item{warmup}{Optional positive integer that specifies the number of iterations per chain that are discarded from the total number of iterations, \code{iter}.
Defaults to \code{1000}. The parameter is given to the method \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()} from the package \code{\link[rstan:rstan]{rstan-package}}.
The function enforces \code{warmup} to be at least \code{1000}, and further that \code{iter} is larger or equal than \code{warmup + 1000} (to ensure
that at least 1000 samples from each chain are kept).}

\item{adapt_delta}{Optional numerical that must be at least \code{0.6} and smaller than \code{1}, defaults to \code{0.8}. The parameter is given to the argument \code{control} of the \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()}
method from the package \code{\link[rstan:rstan]{rstan-package}}. Translates to target Metropolis acceptance probability during Hamiltonian Monte Carlo, respectively NUTS.
Can be used to influence the \code{stepsize} Stan uses for leapfrog steps during the NUTS algorithm. See \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()}, \code{\link[rstan:rstan]{rstan-package}} for details and further reading.

Note: Larger values than the default can be used to reduce the number of Stan warnings on "divergent transition", but will slow down sampling. The function will not
permit to set \code{adapt_delta} to values below 0.6 (the \code{\link[rstan:rstan]{rstan-package}} default).}

\item{max_treedepth}{Optional integer that must be at least \code{10}, defaults to \code{15}. The parameter is given to the argument \code{control} of the \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()}
method from the package \code{\link[rstan:rstan]{rstan-package}}. This is a parameter of the NUTS algorithm. Roughly speaking, NUTS constructs
a search tree when generating a new proposal, until a stopping criterion (the NUTS criterion) is satisfied or, alternatively, until
the maximum depth of the search tree is reached (to avoid endless looping). The argument \code{max_treedepth} allows to control the latter.
The maximum treedepth will also automatically constrain the maximum number of leapfrog steps, and should therefore not be below 10.
See also \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()} for details on \code{max_treedepth}.

Note: The default maximum treedepth of 15 should usually not be reached during sampling (and never was in tests, although this cannot be excluded in general), otherwise Stan will print a warning.
In this case, it is recommended to increase its value.}

\item{refresh}{Optional integer, defaults to \code{0}. The parameter is given to the \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()}
method from the package \code{\link[rstan:rstan]{rstan-package}} and controls the amount of intermediate output during calls to \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()}.
Only affects non-parallelized simulations (otherwise it only affects the output of each worker, which is discarded anyway). If a positive value is given, the number is
interpreted as the number of samples after which intermediate progress is reported during MCMC sampling (e.g., when set to 1000, Stan prints a progress report every 1000 samples).
If refresh is \code{0} (the default) or negative, no output will be printed during sampling. Changing the value of \code{refresh} does not
affect the results of the simulation, although it is recommended to not change it to a positive number: the function can lead to many
calls to \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()} (multiple thousand when 1000 trials are simulated), so that intermediate output would
not be helpful or interpretable in most settings anyway.}

\item{file.name}{Optional character string that provides a name for potential output files. No output will be written if \code{file.name} or \code{path}
are not specified, and in this case, all outputs are only returned to R. If both are given, an excel sheet with the simulation results is written to disk.}

\item{path}{Optional character string that specifies the path to the output directory. No output will be written if \code{file.name} or \code{path}
are not specified, and in this case, all outputs are only returned to R. If both are given and \code{path} points to a directory, an excel sheet
an excel sheet that contains the simulation results is written to the specified location.}

\item{monitor.path}{Optional character string that specifies a path to an additional output directory for monitoring simulation progress.
More precisely, if \code{monitor.path} is not \code{NULL} (the default) and a valid \code{file.name} was given,
the function will write an output file for each completed trial to \code{monitor.path} (provided that it specifies a writable directory).
This can be used to monitor the progress of (parallelized) simulations, which may take multiple hours to simulate.}

\item{working.path}{Optional character string that specifies a path to a directory for temporary results. This directory is then used
to save MCCM results for a given data scenario under unique (hashed) file names, which allows re-loading MCMC runs whenever the same
data scenario occurs in some later trial. This also works for parallelized simulations. File names of temporary results will use the given
\code{file.name} concatenated with "_tmp" as prefix. Do not modify such files manually to avoid errors. To avoid reloading results from previous simulations (with potentially different
MCMC settings or priors), the function will check for files whose name contains the \code{file.name} and "_tmp" from the directory
specified in \code{working.path} before the simulation.
If such files are detected, an error will be thrown. To allow the function
to automatically delete all such files from the \code{working.path} before and after the simulation, consider using the argument \code{clean.working.path}.}

\item{clean.working.path}{Optional logical, defaults to \code{FALSE}. Indicates whether the function is allowed to delete any existing files that contain
\code{file.name} and "_tmp" in their name from the directory
specified in \code{working.path}. If \code{TRUE}, such temporary files will be automatically removed from the working directory before
and after simulation. If \code{FALSE}, the function will check for such file names initially and throw an error when such files are found.}

\item{output.sim.config}{Optional logical that specifies whether the input parameters of the call to \code{sim_jointBLRM()} are added to
the output list (or, if activated, the output files written to disk). Defaults to \code{TRUE}. This can be used to save e.g. the seed, dose-toxicity scenarios, and
priors of the simulation to allow double-checking the configuration of the simulation at a later point in time.}
}
\value{
List that contains a number of metrics that summarize the results of the simulation for each simulated trial,
and, depending on the specification, additional list entries that save the given input specification.

By default, the following list entries are generated for each simulated trial (where \code{[...]}
is the corresponding suffix of the trial):
\itemize{
\item{\code{...$'results [...]'}\cr Overview of number of MTDs per dosing interval (under, target, over), and number of
trials that stopped without finding an MTD, either due to the stopping rule (when
EWOC-based escalation is used) or due to reaching the maximal patient number.}

\item{\code{...$'summary [...]'}\cr Summary statistics (mean, median, min, max, 2.5\% and 97.5\% quantile) of
the number of patients, patients per dosing interval, DLTs, and
DLTs per dosing interval.}

\item{\code{...$'MTDs [...]'}\cr Number of MTDs per dose level and their assumed DLT rates.}

\item{\code{...$'#pat [...]'}\cr Mean, median, minimum and maximum number of patients enrolled at each dose level.}
}
Additionally, if \code{output.sim.config} is active, the list will include the following entries:
\itemize{
\item{\code{...$'historical.data'}\cr Only included when historical data was included in the simulations. Contains the specified cohorts
from historical data.}

\item{\code{...$'prior'}\cr The prior distribution for the hyper-parameters that was used by the BLRM.}

\item{\code{...$'specifications'}\cr All other simulation specifications. Includes e. g. reference doses, decision rules, escalation steps,
and the seed.}

\item{\code{...$'Stan options'}\cr Options given to Stan, such as the number of MCMC iterations and chains.}
}
}
\description{
Simulates dose-finding trials with up to six parallel monotherapy or two-drug combination therapy trials modeled together in a
joint BLRM. The function assumes that two different compounds are involved, compounds 1 and 2 (and their combination).
Up to two monotherapy trials for each compound can be actively simulated, and additionally two combination therapy trials.
Note that the term "trial" can in this context also refer to trial arms (e.g. monotherapy and combination therapy), and
that the underlying model will not differentiate between these notions.
The order in which cohorts for the simulated trials are enrolled can be specified freely. Further, besides the actively simulated
trials, the function supports the inclusion of historical data from arbitrarily many previous (already concluded)
dose-finding trials for the considered compounds.

The function expects a specification of dose levels and their assumed DLT rates for each involved trial, based on which the course of
the dose-finding trial is simulated. Additional customization of the simulations is possible (separately for each simulated trial),
e.g. regarding the escalation rule (EWOC and loss-based methods), definition of MTD, the maximum increment of escalations,
the numbers of patients per cohort, and further specifications.

The six possible trials are encoded with the following suffixes: \code{mono1.a}, \code{mono1.b}, \code{mono2.a},
\code{mono2.b}, \code{combi.a}, and \code{combi.b}. The ending (\code{.a} or \code{.b}) differentiates between two different
trials of the same kind, i.e., monotherapy for compound 1 (\code{mono1}), monotherapy for compound 2 (\code{mono2}), and combination therapy (\code{combi}).
For some function arguments, one version of the argument is available for each trial (differentiated via their suffixes),
so that different simulated trials may use different specifications in terms of e.g. dose levels, assumed DLT rate,
and starting dose.

To differentiate between the up to six simulated trials and the actual simulation run that processes one realization
of the activated trials, we will in the following use the term "study" for a single simulation run that
determines a realization of each activated trial using the given specifications. For instance, if two
trials are active, say \code{mono1.a} and \code{combi.a}, the term "trial" refers to the simulated trials
with these names, while the notion "study" means a simulation run of both trials in the specified order
and under the given input assumptions. Simulating e.g. 1000 studies means in this context that the trials
\code{mono1.a} and \code{combi.a} are simulated in the specified order using the specified options for 1000 times.

Most of the parameters have sensible defaults and will often not need to be specified explicitly.
The recommended workflow to set up the function is as follows:
\itemize{
\item{Specify reference doses.}
\item{Optional: Specify available historical data and, if needed, specific priors for the model (the default ones are weakly informative).}
\item{Specify dose levels, starting doses and assumed DLT rates for each trial that needs to be simulated, and
activate the corresponding trials via the \code{active.[...]} arguments.}
\item{Set the number of trials to be simulated.}
\item{Optional: Specify additional options for the simulations.}
\item{Optional but strongly recommended: Enable parallel simulation and specify the number of cores, and supply a path for a working directory
for saving and re-loading MCMC results. When a working directory is supplied, be aware that the function will delete or modify
existing .RData files containing "_tmp" and the supplied \code{file.name} in their name from the working directory to avoid
re-loading MCMC runs from previous simulations.
Refer to the documentation below for more detail.}
\item{Run the simulation. Note that simulations of e.g. 1000 trials may take multiple hours depending on the specifications.}
}
}
\details{
The joint BLRM is defined according to (Neuenschwander et al., 2014 and 2016). It allows to perform Bayesian logistic regression
to estimate the dose-toxicity relationship of two different monotherapies and combination therapy with these compounds in
a joint model, which includes a hierarchical prior for robust borrowing across trials. Refer to the documentation of
\code{\link[OncoBLRM:scenario_jointBLRM]{scenario_jointBLRM}()} for a detailed model description.
}
\references{
Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.21.2. \url{https://mc-stan.org}.

Neuenschwander, B., Branson, M., & Gsponer, T. (2008). Critical aspects of the Bayesian approach to phase I cancer trials.
Statistics in medicine, 27(13), 2420-2439, \url{doi:10.1002/sim.3230}.

Neuenschwander, B., Matano, A., Tang, Z., Roychoudhury, S., Wandel, S., & Bailey, S. (2014). A Bayesian Industry Approach to Phase I Combination Trials in Oncology.
In: Zhao. W & Yang, H. (editors). Statistical methods in drug combination studies. Chapman and Hall/CRC, 95-135, \url{doi:10.1201/b17965}.

Neuenschwander, B., Roychoudhury, S., & Schmidli, H. (2016). On the use of co-data in clinical trials.
Statistics in Biopharmaceutical Research, 8(3), 345-354, \url{doi:10.1080/19466315.2016.1174149}.

Babb, J., Rogatko, A., & Zacks, S. (1998). Cancer phase I clinical trials: Efficient dose escalation with overdose control.
Statistics in medicine 17(10), 1103-1120.

Zhou, H.,  Yuan, Y., & Nie, L. (2018). Accuracy, safety, and reliability of novel phase I designs.
Clinical Cancer Research, 24(21), 5483-5484 <doi: 10.1158/1078-0432.ccr-18-0168>.
}
\seealso{
\code{\link[OncoBLRM:scenario_jointBLRM]{scenario_jointBLRM}()}, \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling}()},
\code{\link[rstan:rstan]{rstan-package}}.
}
