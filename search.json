[{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright [yyyy] [name of copyright owner]  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"overview-of-the-main-tools","dir":"Articles","previous_headings":"","what":"Overview of the main tools","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"package ships two main functions, called scenario_jointBLRM sim_jointBLRM. former essentially high-level wrapper fitting joint BLRM concrete data scenario, latter allows simulate course number dose-finding trials assumption specific dose-toxicity scenario, .e. specification DLT rates involved dose levels.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"scenario_jointblrm","dir":"Articles","previous_headings":"Overview of the main tools","what":"scenario_jointBLRM","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"function scenario_jointBLRM essentially wrapper Stan model joint BLRM, internally used sample posterior distribution given set input data using -called -U-Turn sampler (NUTS) algorithm. details technicalities behind Stan, good starting place Stan’s homepage. However, besides fitting model, function also perform number evaluations based posterior. importantly, posterior distribution DLT rates (referred posterior toxicities following) given set dose levels determined based fitted model. actual dose-finding trials distributions form basis recommended dose level next cohort. output scenario_jointBLRM consist summary posterior toxicities, well evaluation terms specific escalation rule. , term escalation rule refers method derives dosing recommendation based fitted BLRM. Currently, decider package supports popular escalation overdose control (EWOC)-based escalation rules (Babb, Rogatko, Zacks 1998), well loss-based escalation rules, however considered vignette. Note EWOC-based escalation default setting functions, without specifications, functions assume EWOC applied. Essentially, EWOC computes probability DLT rate dose lies prespecified target dosing interval (often 16% 33% DLT rate), demands probability exceed certain boundary, typically 0.25 (default). interval boundary can adapted user. EWOC-based escalation, summary scenario_jointBLRM creates contain resulting posterior interval probabilities underdosing, target dosing, overdosing, well summary statistics posterior DLT rates given set doses interest (usually set possible dose levels trial). Additionally, plots posterior interval probabilities can created, visualize EWOC principle set doses allowed EWOC based given data. main uses scenario_jointBLRM evaluation actual hypothetical data scenarios determination resulting posterior. Actual data scenarios refer data observed trial, hypothetical data scenarios way evaluating -trial behavior BLRM escalation rule concrete setting. particularly important planning stage dose-finding trials, allow monitor performance model scenarios assumed potentially occur trial. Based evaluations, prior distribution BLRM can adapted obtain appropriate escalation behavior. evaluating prior specification planning stage trial, one typically need consider whole set different scenarios test model recommendation broad spectrum possible situations. Specifically setting, additional function scenario_list_jointBLRM() provided, allows evaluate list arbitrarily many scenarios via scenario_jointBLRM() parallel.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"sim_jointblrm","dir":"Articles","previous_headings":"Overview of the main tools","what":"sim_jointBLRM","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"prior appropriate -trial behavior established, one may want conduct thorough evaluation performance resulting model. widely-accepted way achieving trial simulations. , one assumes concrete “true” DLT rates dose levels available trial (referred dose-toxicity scenario) repeatedly simulates number DLTs observed cohorts patients. Based data, BLRM fitted escalation rule applied determine dose level next cohort, , potentially, trial needs stopped early (can e.g. happen lowest available dose satisfy EWOC criterion). process repeated prespecified condition declaration MTD reached, trial stopped without declaring MTD (either due stopping early due reaching maximum number patients can enrolled). trial simulation can used determine operating characteristics trial design specific dose-toxicity scenarios. , one simulates number trials, e.g. 1000, determines ratio MTDs declared specific dose levels (e.g., MTDs target doses), well quantities like average number patients treated specific dose average number DLTs occurred trial. process repeated number different scenarios, containing e.g. low-toxicity scenarios (doses DLT rate targeted interval), moderate scenarios (DLT rates range underdoses target doses overdoses), highly toxic scenarios, extreme cases, like e.g. one trial considerably toxic another one. function sim_jointBLRM() designed perform simulations convenient manner generate output tables summarize operating characteristics specified trial design concrete dose-toxicity scenarios. provides option two simulate six trials running parallel (can activated independently ), namely two monotherapy trials involved compound, two combination therapy trias included joint meta-analytic BLRM specified according (Neuenschwander et al. 2014), (Neuenschwander, Roychoudhury, Schmidli 2016). priors used model order cohorts arrive can freely specified user, well many options, including escalation rules, MTD selection, starting doses, additional restrictions increment escalations. Furthermore, function allows include data arbitrarily many historical trials (actively simulated) involved compounds.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"setting-up-and-evaluating-priors-using-scenario_jointblrm","dir":"Articles","previous_headings":"","what":"Setting up and evaluating priors using scenario_jointBLRM","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"Assume following interested setting oncology dose-finding study includes two different trials, referred Arm Arm B following. Suppose Arm investigates treatment, say compound 1, first--human monotherapy setting, Arm B shall consider combination therapy compound 1 combination partner, say compound 2. assume previous dose-finding trials compound 2 already conducted, DLT data available monotherapy compound 2 earlier clinical investigations. Assume Arm Arm B shall run partially parallel, , precisely, Arm B initiated Arm concluded (trial declared MTD), provided involved doses compound 1 already tested monotherapy. allow exchange information across Arms B, inclusion historical data compound 2, model trials historical trials joint BLRM. following sections provide overview function scenario_jointBLRM can set situation, used specify evaluate appropriate prior distribution conduct analyses determine next dose level trial. continue, forget load decider package.","code":"library(decider)"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"basic-specifications-of-scenario_jointblrm","dir":"Articles","previous_headings":"Setting up and evaluating priors using scenario_jointBLRM","what":"Basic specifications of scenario_jointBLRM","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"first step, determine necessary fixed input data, consisting set available dose levels Arms ad B, set historical data, reference dose levels compounds. First, assume historical monotherapy trial compound 2, clinical data given available. Dose levels compound assumed stated fixed unit measurement, e.g. mg mg/kg, explicitly denoted simplicity. assumed observations originate single historical trial, although easily extended multiple historical trials (described ). given data now needs written format scenario_jointBLRM accepts, named list containing entries dose1, dose2, n.pat, n.dlt, trial. data given , use , column structure given translates data observed one dose level specific historical trial. Note dose levels compound 2 given entry dose2, entry dose1 0 indicate cohorts received monotherapy compound 2. example , data one historical trial included. , entry historical.data$trial given historical cohort, tells function cohorts belong trial. entry \"H1\" arbitrarily chosen trial name historical trial, note one also use specific number string trial name. data multiple historical trials given, multiple trial names need used indicate . next step, need specify reference dose levels set available dose levels trial. Although set investigational dose levels can flexible practice (.e., need full specification planning stage), prior evaluations, hypothetical set doses planned used trial need specified allow evaluating hypothetical -trial behavior model. following assume planned monotherapy doses compound 1 left unit measurement (e.g. g mg/kg) simplicity. Regarding combination therapy, suppose planned consider combinations monotherapy doses compound 1 dose levels compound 2 (given unit measurement doses historical data). planned monotherapy combination therapy doses given function via argument doses..interest, specifies dose levels need evaluated. argument needs matrix two rows one column dose level, monotherapy doses indicated placing 0 NA entry compound. setting specified , results Next, need specify reference doses used joint BLRM. assume compound 1 dose 6 compound 2 dose 12 selected : explicitly tell function interested two trials consider monotherapy compound 1, respectively combination therapy, now include following optional arguments: trial names \"\" \"B\" arbitrary tell function indicate two trials data. types \"mono1\" \"combi\" specify doses..interest corresponding trial type need analyzed corresponding trial. , trial \"\" trial type \"mono1\" consider monotherapy compound 1, \"combi\" indicates trial \"B\" consider combination therapy doses. also type \"\" cause function analyze given doses interest trial. trials interest type explicitly specified, function use trial names given data historical data (case, including trial \"H1\" historical data), try infer type given data trial. possible, (e.g. data given yet), function provide posteriors doses interest trial. Therefore, specifying trials interest types allows control output included precise fashion. Furthermore, provide data trial \"\" \"B\" yet (e.g. obtain predictive distribution induced data included trials), function include posterior trial output unless name specified explicitly trial interest. instance, historical data given, function estimate posterior historical trials estimate predictive distribution new trial based historical data. point, principle already run function produce posterior predictive distributions trials \"\" \"B\" purely historical data trial \"H1\" (equivalent meta-analytic predictive prior, cf. (Neuenschwander, Roychoudhury, Schmidli 2016)). However, still specified (hyper-)prior distribution model, function apply default prior configuration (refer documentation scenario_jointBLRM). default prior weakly informative found quite flexible across different situations, still recommended specify prior manually ensure good -trial behavior model subject next section.","code":"historical.data = list(   dose1 = c( 0,    0,    0,    0,    0),   dose2 = c( 2,    4,    8,    12,   16),   n.pat = c( 3,    3,    3,    9,    12),   n.dlt = c( 0,    0,    0,    1,    2),   trial = c(\"H1\", \"H1\", \"H1\", \"H1\", \"H1\") ) d1 = c(0.1, 0.2, 0.4, 0.8, 1.6, 2.4, 3.6, 5, 6) d2 = c(8, 12) doses.of.interest = rbind( c(d1,                  rep(d1, times=length(d2))),                            c(rep(0, length(d1)),  rep(d2, each=length(d1))) )  #monotherapy compound 1. doses.of.interest[, 1:length(d1)] #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #> [1,]  0.1  0.2  0.4  0.8  1.6  2.4  3.6    5    6 #> [2,]  0.0  0.0  0.0  0.0  0.0  0.0  0.0    0    0  #combinations of compound 1 with dose 8 of compound 2. doses.of.interest[, (length(d1)+1):(2*length(d1))] #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #> [1,]  0.1  0.2  0.4  0.8  1.6  2.4  3.6    5    6 #> [2,]  8.0  8.0  8.0  8.0  8.0  8.0  8.0    8    8  #combinations of compound 1 with dose 12 of compound 2. doses.of.interest[, (2*length(d1)+1):(3*length(d1))] #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #> [1,]  0.1  0.2  0.4  0.8  1.6  2.4  3.6    5    6 #> [2,] 12.0 12.0 12.0 12.0 12.0 12.0 12.0   12   12 dose.ref1 = 6 dose.ref2 = 12 trials.of.interest = c(\"A\",     \"B\") types.of.interest =  c(\"mono1\", \"combi\")"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"specifying-a-prior-for-the-joint-blrm","dir":"Articles","previous_headings":"Setting up and evaluating priors using scenario_jointBLRM","what":"Specifying a prior for the joint BLRM","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"Refer section Detail documentation scenario_jointBLRM model specification joint BLRM explanations model . following, important know prior specifications consist two parts, namely, prior hyper-means (argument prior.mu) prior -trial heterogeneities (argument prior.tau), hyper-mean shared mean parameters across trials -trial heterogeneity standard deviation across trials. Recall five different parameters joint BLRM: two parameters compound (precisely, intercept \\(log(\\alpha_i)\\) log-slope \\(log(\\beta_i)\\) compound \\(\\)), interaction parameter, \\(\\eta\\). Hence, prior specification must specify distribution hypermean -trial heterogeneity five parameters. , assumed hypermeans follow normal distributions fixed mean SD (therefore input required specify distribution hypermean), heterogeneities assumed follow log-normal distributions, whose mean SD (log-scale) need given function. Technically, assumed \\(\\), \\(log(\\alpha_i)\\) \\(log(\\beta_i)\\) may correlated correlation coefficient \\(\\rho\\), hyperparameter automatically assigned uniform distribution interval \\([-1, 1]\\), prior need specified.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"prior-for-the-hypermeans-prior-mu","dir":"Articles","previous_headings":"Setting up and evaluating priors using scenario_jointBLRM > Specifying a prior for the joint BLRM","what":"Prior for the hypermeans: prior.mu","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"First, consider prior hypermeans, encoded argument prior.mu. must list five named entries, entry provides mean SD distribution one five hypermeans. expected format argument : , prefix mu indicates hypermean, suffixes correspond parameters given following table. prior list, entries form c(x, y), x gives mean y SD normal distribution assumed hypermean corresponding parameter. default values oriented towards (Neuenschwander et al. 2014) (Neuenschwander, Roychoudhury, Schmidli 2016), represent relatively flexible, weakly informative prior distribution. recommended used starting point adapting prior given setting, specific modifations match setting concrete trial likely provide better performance default prior. Regarding interpretation parameter, \\(log(\\alpha_i)\\) gives median log-odds experiencing DLT following treatment reference dose. value -0.7081851 corresponds means one assumes reference dose median DLT rate 33%. corresponds precisely upper boundary default target interval (16% 33%), prior expresses assumption reference dose priori possible candidate MTD (note reference dose chosen accordingly). default value SD hypermeans \\(log(\\alpha_i)\\) 2, represents relatively large uncertainty leads relatively flexible prior. Note however depending dosing range specifications trial, one might want deviate default value. instance, may want assume slightly larger uncertainty regarding intercept obtain conservative setup, e.g. via Regarding hyperpriors \\(log(\\beta)\\), standard normal distribution assumed. covers relatively broad range slopes, although one may want select larger smaller SD certain cases. Regarding mean, typically necessary deviate default 0 unless concrete information shape dose-toxicity relationship. interaction parameter, recall negative values \\(\\eta\\) express lower DLT rate dose combinations interaction free-case (compounds cause DLT fully independently ), positive values lead larger DLT rate compared interaction-free case. default value \\(0\\) mean expresses positive negative interactions may occur, SD 1.121 selected 95% credible interval interaction-parameters corresponds increase 9-fold (decrease factor 9) odds DLT reference dose. Larger lower values mean SD can used obtain aggressive conservative behavior combination trials. Refer e.g. (Neuenschwander et al. 2014) detail .","code":"#               Parameter    Mean        SD prior.mu = list(mu_a1  =  c(-0.7081851, 2),                 mu_b1  =  c(0,          1),                 mu_a2  =  c(-0.7081851, 2),                 mu_b2  =  c(0,          1),                 mu_eta =  c(0,          1.121)) logit(0.33) #> [1] -0.7081851 prior.mu = list(mu_a1  =  c(-0.7081851, 3),                 mu_b1  =  c(0,          1),                 mu_a2  =  c(-0.7081851, 3),                 mu_b2  =  c(0,          1),                 mu_eta =  c(0,          1.121))"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"prior-for-the-between-trial-heterogeneities-prior-tau","dir":"Articles","previous_headings":"Setting up and evaluating priors using scenario_jointBLRM > Specifying a prior for the joint BLRM","what":"Prior for the between-trial heterogeneities: prior.tau","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"prior parameters -trial heterogeneity control amount borrowing performed across trials. context, assumption larger heterogeneity parameter allows parameter show larger variance across trials, , consequently, reduces influence data trials jointly modeled trial. decider package assumes -trial heterogeneities follow log-normal distributions, specified providing mean SD log-scale. default value required format prior.tau : naming conventions prior.mu. Note value c(x,y) tau_[...] provides mean x SD y log-scale, .e. corresponding hyperparameter denoted \\(\\tau\\), function assumes \\(\\tau=exp(\\psi)\\) random variable \\(\\psi\\) normally distributed mean x SD y. default values oriented towards (Neuenschwander et al. 2014). Note SDs typically set either log(2)/1.96 log(4)/1.96 (larger uncertainty), values usually needed. specify mean -trial heterogeneities, one typically assumes specific degree heterogeneity (cf. table ). default, scenario_jointBLRM assumes mean log(0.25) -trial heterogeneity \\(log(\\alpha_i)\\), log(0.125) heterogeneity remaining parameters. natural (non-log) scale, means differences parameters across trials median expected 0.25, respectively 0.125. usually referred “moderate” -trial heterogeneity, potential values mean can found following table. Regarding prior setup -trial heterogeneity, chosen prior depend expected differences across trials number patients included co-data (larger number patients may require heterogeneity ensure sufficient robustness). many situations, moderate substantial configurations table provide acceptable robustness, typically considered good starting points prior evaluations. Besides evaluations hypothetical scenarios simulations (covered following sections), prior effective sample sizes also provide good way evaluating influence co-data trial interest adjusting priors -trial heterogeneity accordingly. Refer (Neuenschwander et al. 2020) detail type method assessing information included prior.","code":"#                Parameter    Mean        SD prior.tau = list(tau_a1  =  c(log(0.25),  log(2)/1.96),                  tau_b1  =  c(log(0.125), log(2)/1.96),                  tau_a2  =  c(log(0.25),  log(2)/1.96),                  tau_b2  =  c(log(0.125), log(2)/1.96),                  tau_eta =  c(log(0.125), log(2)/1.96))"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"using-scenario_jointblrm-to-evaluate-hypothetical-data-scenarios","dir":"Articles","previous_headings":"Setting up and evaluating priors using scenario_jointBLRM","what":"Using scenario_jointBLRM to evaluate hypothetical data scenarios","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"Hypothetical data scenarios evaluate decisions BLRM number concrete situations might occur trial planned. one can usually foresee evaluate possible situations (mostly due many ), one restricts evaluations important classes settings. include limited : Early scenarios assess decisions within first cohorts trial, especially scenarios assume early DLTs. Late scenarios assess resulting MTD estimates based planned number patients (slightly fewer). Scenarios assess specific critical dosing recommendations, e.g. whether escalation rule ceases increase dose observing certain DLT rates. Scenarios assume heterogeneous co-data. , e.g. assessed whether decision rule can correctly decide settings involved trials trials show substantially different toxicities. Similarly previous point, multiple parallel trials involved start different points time, assessed co-data influences start trials. instance, can happen combination trial allowed started planned starting dose due toxic monotherapy data. therefore assessed (aligned ones recommendations) co-data needed allow planned starting dose, cases recommended model. example, consider scenario first cohort 3 patients treated dose 0.1 compound 1 second cohort dose 0.2. assume DLT occurred first cohort, one patients second cohort experienced DLT. translates data scenario: Note \"\" used trial name monotherapy trial compound 1, needs match name specified trials..interest argument. Now, scenario function can called. Using previously specified objects, function can applied via Note output contains two entries, one trial interest. previously specified types trials, posterior toxicities trial \"\" computed doses interest represent monotherapy compound 1, posteriors trial \"B\" contain combination therapy dose levels. doses, interval probabilities computed, well summary statistics posterior toxicities. default, considered interval probabilities assume target interval (range DLT rates considered appropriate MTD) \\([0.16, 0.33)\\). However, one interested different interval, say, \\([0.2, 0.3)\\), can achieved supplying optional argument dosing.intervals = c(0.2, 0.3). context, underdosing, respectively overdosing intervals contain DLT rates , respectively target interval. customization output can achieved supplying argument probs, specifies quantiles listed output tables. default, reported quantiles 2.5%, 50%, 97.5%. additional quantiles shall computed, say, 25% 75%, can achieved e.g. probs = c(0.025, 0.25, 0.5, 0.75, 0.975). additional output plots shall created (required prior evaluation, potentially helpful actual analyses), one can activate via plot.decisions = TRUE. Usually, simple bar plots created argument monotherapy, heatmap combination therapy. additionally setting plot.return = TRUE, plots contained results list form ggplot objects. Refer documentation ggplot2 package detail type object. ggplot2 package also provides broad range functions can used customize returned plots . plot.return specified, function print plots potentially save user specified path outputs. Additionally, one may want control number digits output rounded , especially considering heatmap-type plots combination therapy, using e.g. digits = 3. generated plots shown plot panel RStudio. explicitly display returned ggplot objects, one can access follows. Plot generated scenario_jointBLRM() trial \"\" Plot generated scenario_jointBLRM() trial \"B\" Note supplied additional argument, ewoc.threshold, call scenario_jointBLRM. argument states feasibility bound EWOC criterion (cf. Babb et al. (1998)) displayed plots indicate doses fulfilling EWOC criterion (used next cohort). argument optional defaults 0.25 specified, actually needed unless different value shall used feasibility bound EWOC criterion. options customizing plots, e.g. indicate type plots used combination therapy trials (heatmap bar diagram). Detail arguments output plots specified documentation. One can also enable automatic saving posterior summaries supplying optional arguments file.name path. latter specifies valid (writable) directory, output saved .xlsx file specified file.name. Additionally, one can save output plots specifying plots.save = TRUE (provided valid path file.name supplied). case, recommended specify format output plots via plot.unit, plot.width, plot.height. Refer documentation detail .","code":"scenario1 = list(   dose1 = c( 0.1,  0.2),   dose2 = c( 0,    0),   n.pat = c( 3,    3),   n.dlt = c( 0,    1),   trial = c(\"A\",  \"A\") ) result1 <- scenario_jointBLRM(   data = scenario1,   historical.data = historical.data,   doses.of.interest = doses.of.interest,   dose.ref1 = dose.ref1,   dose.ref2 = dose.ref2,   trials.of.interest = trials.of.interest,   types.of.interest = types.of.interest,   prior.mu = prior.mu,   prior.tau = prior.tau )  print(result1) #> $`trial-A` #>          mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+0 0.11859 0.11397 0.00277 0.08298 0.42437     0.73012        0.20692     0.06296 #> 0.2+0 0.16858 0.14123 0.00622 0.13118 0.52599     0.57770        0.28426     0.13804 #> 0.4+0 0.23990 0.18077 0.01177 0.19979 0.66828     0.41439        0.30802     0.27759 #> 0.8+0 0.32845 0.22607 0.01943 0.28842 0.82258     0.28763        0.27302     0.43935 #> 1.6+0 0.42193 0.26338 0.02855 0.39217 0.92793     0.19970        0.22465     0.57565 #> 2.4+0 0.47413 0.27850 0.03468 0.45659 0.96162     0.16412        0.19714     0.63874 #> 3.6+0 0.52269 0.28863 0.04127 0.52290 0.98040     0.13637        0.17219     0.69144 #> 5+0   0.55892 0.29362 0.04641 0.57564 0.98885     0.11860        0.15342     0.72798 #> 6+0   0.57778 0.29531 0.04980 0.60451 0.99195     0.11001        0.14404     0.74595 #>  #> $`trial-B` #>           mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+8  0.18629 0.13531 0.02394 0.15155 0.53989     0.52862        0.33361     0.13777 #> 0.2+8  0.23094 0.15907 0.03199 0.19187 0.63372     0.40750        0.36679     0.22571 #> 0.4+8  0.29299 0.18960 0.04220 0.25081 0.74998     0.28991        0.35425     0.35584 #> 0.8+8  0.37122 0.22352 0.05499 0.33055 0.86179     0.19460        0.30452     0.50088 #> 1.6+8  0.45729 0.25390 0.06750 0.43033 0.94195     0.13229        0.24075     0.62696 #> 2.4+8  0.50649 0.26808 0.07326 0.49341 0.96861     0.11074        0.20394     0.68532 #> 3.6+8  0.55217 0.27991 0.07487 0.55814 0.98426     0.09771        0.17248     0.72981 #> 5+8    0.58535 0.28891 0.07207 0.61212 0.99170     0.09375        0.15140     0.75485 #> 6+8    0.60188 0.29425 0.06797 0.64102 0.99437     0.09407        0.14083     0.76510 #> 0.1+12 0.22163 0.13567 0.04560 0.19111 0.56602     0.39149        0.42356     0.18495 #> 0.2+12 0.26436 0.15705 0.05503 0.23029 0.65521     0.29229        0.42656     0.28115 #> 0.4+12 0.32378 0.18514 0.06661 0.28640 0.76281     0.20083        0.38479     0.41438 #> 0.8+12 0.39874 0.21714 0.07997 0.36279 0.86979     0.13339        0.31136     0.55525 #> 1.6+12 0.48109 0.24729 0.09018 0.45862 0.94615     0.09510        0.23439     0.67051 #> 2.4+12 0.52780 0.26299 0.09012 0.52017 0.97151     0.08508        0.19534     0.71958 #> 3.6+12 0.57027 0.27851 0.08220 0.58428 0.98658     0.08529        0.16244     0.75227 #> 5+12   0.59971 0.29270 0.06724 0.63718 0.99349     0.09417        0.14046     0.76537 #> 6+12   0.61346 0.30184 0.05647 0.66692 0.99585     0.10270        0.12933     0.76797 result1a <- scenario_jointBLRM(   data = scenario1,   historical.data = historical.data,   doses.of.interest = doses.of.interest,   dose.ref1 = dose.ref1,   dose.ref2 = dose.ref2,   trials.of.interest = trials.of.interest,   types.of.interest = types.of.interest,   prior.mu = prior.mu,   prior.tau = prior.tau,   plot.decisions = TRUE,   plot.return = TRUE,   ewoc.threshold = 0.25,   digits = 3 ) plot(result1a$plots$\"trial-A\") plot(result1a$plots$\"trial-B\")"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"evaluating-multiple-scenarios-in-parallel","dir":"Articles","previous_headings":"Setting up and evaluating priors using scenario_jointBLRM","what":"Evaluating multiple scenarios in parallel","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"setting prior, one typically want evaluate number scenarios , , Bayesian computation tends take relatively long, may rather slow e.g. 10 scenarios. Additionally, one need e.g. 10 () calls scenario_jointBLRM, may practical scenarios repeatedly evaluated slightly altered prior specifications. provide slightly convenience types exercise, function scenario_list_jointBLRM allows perform multiple calls scenario_jointBLRM parallel list data scenarios, speeds computation simplifies evaluation number hypothetical settings. Please note parallel backend needs registered leverage parallelization, otherwise function executed sequentially. example provided . use , consider first (numbered) list data scenarios. specified list lists, sublist must format expected data argument scenario_jointBLRM. instance, list 8 scenarios look like : Note Scenario 8 also contains cohorts combination therapy trial, encoded trial name \"B\" specified previously. cohorts can given arbitrary order. run evaluations parallel, one can additionally register paralell backend. various existing packages can achieve . basic construct register parallel backend using doFuture package following example, 1 core selected, identical sequential execution. practice, n.cores can set depending available processor function running. Now, coming back evaluation scenarios, registration parallel backend one can simply use , except first argument, data.list, provided precisely arguments call scenario_jointBLRM previous section. also work (optional) arguments scenario_jointBLRM, except file.name. Instead argument, scenario_list_jointBLRM uses optional argument file.names (notice plural), function file.name scenario_jointBLRM, needs contain vector file name scenario instead. , argument ignored unless want save output supplied path. Note historical data provided scenario_list_jointBLRM included posterior evaluations every scenario, .e., historical data interpreted fashion scenario_jointBLRM, vary across scenarios list. obtain prior configuration, now recommended create sufficiently large number scenarios, repeatedly evaluate scenarios gradually alter prior distribution obtain appropriate setup behavior considered scenarios. However, mentioned , one probably able consider every potential scenario advance, mostly heuristic check guaranteed yield optimal prior. Due , evaluation prior performed confirm shows appropriate operating characteristics long-run. subject following section.","code":"data.list = list(    #Scenario 1   list(     dose1 = c( 0.1),     dose2 = c( 0),     n.pat = c( 3),     n.dlt = c( 0),     trial = c(\"A\")),    #Scenario 2   list(     dose1 = c( 0.1),     dose2 = c( 0),     n.pat = c( 3),     n.dlt = c( 1),     trial = c(\"A\")),    #Scenario 3   list(     dose1 = c( 0.1),     dose2 = c( 0),     n.pat = c( 3),     n.dlt = c( 2),     trial = c(\"A\")),    #Scenario 4   list(     dose1 = c( 0.1,  0.2),     dose2 = c( 0,    0),     n.pat = c( 3,    3),     n.dlt = c( 0,    1),     trial = c(\"A\",  \"A\")),    #Scenario 5   list(     dose1 = c( 0.1,  0.2),     dose2 = c( 0,    0),     n.pat = c( 3,    3),     n.dlt = c( 0,    2),     trial = c(\"A\",  \"A\")),    #Scenario 6   list(     dose1 = c( 0.1,  0.2,  0.4),     dose2 = c( 0,    0,    0),     n.pat = c( 3,    3,    3),     n.dlt = c( 0,    0,    1),     trial = c(\"A\",  \"A\",  \"A\")),    #Scenario 7   list(     dose1 = c( 0.1,  0.2,  0.4),     dose2 = c( 0,    0,    0),     n.pat = c( 3,    3,    6),     n.dlt = c( 0,    0,    1),     trial = c(\"A\",  \"A\",  \"A\")),    #Scenario 8   list(     dose1 = c( 0.1,  0.2,  0.4,     0.2),     dose2 = c( 0,    0,    0,       8),     n.pat = c( 3,    3,    6,       3),     n.dlt = c( 0,    0,    1,       0),     trial = c(\"A\",  \"A\",  \"A\",     \"B\")) ) library(doFuture)  #specify number of cores -- here, only 1 for a sequential exacution n.cores <- 1  #register backend for parallel execution and plan multisession doFuture::registerDoFuture() future::plan(future::multisession, workers=n.cores) results <- scenario_list_jointBLRM(   data.list = data.list,    historical.data = historical.data,   doses.of.interest = doses.of.interest,   dose.ref1 = dose.ref1,   dose.ref2 = dose.ref2,   trials.of.interest = trials.of.interest,   types.of.interest = types.of.interest,   prior.mu = prior.mu,   prior.tau = prior.tau )  print(results) #> [[1]] #> [[1]]$`trial-A` #>          mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+0 0.02629 0.06901 0.00000 0.00108 0.24157     0.95389        0.03335     0.01276 #> 0.2+0 0.03834 0.09010 0.00000 0.00245 0.32889     0.92537        0.04987     0.02476 #> 0.4+0 0.05776 0.12113 0.00000 0.00562 0.45832     0.88396        0.06689     0.04915 #> 0.8+0 0.08879 0.16322 0.00000 0.01303 0.62015     0.82253        0.08784     0.08963 #> 1.6+0 0.13789 0.21527 0.00000 0.03152 0.79474     0.73684        0.10943     0.15373 #> 2.4+0 0.17913 0.24919 0.00004 0.05380 0.87765     0.67021        0.12268     0.20711 #> 3.6+0 0.23398 0.28456 0.00024 0.09469 0.93795     0.58855        0.13350     0.27795 #> 5+0   0.29191 0.31325 0.00068 0.15226 0.96966     0.50889        0.13965     0.35146 #> 6+0   0.33007 0.32909 0.00101 0.19635 0.98156     0.46268        0.14039     0.39693 #>  #> [[1]]$`trial-B` #>           mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+8  0.09596 0.09113 0.00620 0.07103 0.34521     0.84208        0.12950     0.02842 #> 0.2+8  0.10744 0.10718 0.00681 0.07642 0.41522     0.80799        0.14739     0.04462 #> 0.4+8  0.12558 0.13146 0.00777 0.08460 0.52825     0.76176        0.16513     0.07311 #> 0.8+8  0.15440 0.16589 0.00922 0.09715 0.67305     0.69641        0.18429     0.11930 #> 1.6+8  0.20040 0.21082 0.01139 0.11942 0.82493     0.60701        0.20309     0.18990 #> 2.4+8  0.23946 0.24139 0.01301 0.14203 0.89541     0.53991        0.21173     0.24836 #> 3.6+8  0.29194 0.27425 0.01475 0.18147 0.94769     0.46073        0.21295     0.32632 #> 5+8    0.34776 0.30211 0.01600 0.23634 0.97595     0.38990        0.20507     0.40503 #> 6+8    0.38430 0.31780 0.01583 0.28020 0.98621     0.35231        0.19340     0.45429 #> 0.1+12 0.13536 0.09759 0.02351 0.11183 0.39383     0.70603        0.24972     0.04425 #> 0.2+12 0.14637 0.11139 0.02459 0.11774 0.45308     0.67355        0.26217     0.06428 #> 0.4+12 0.16381 0.13303 0.02590 0.12662 0.55511     0.62862        0.27497     0.09641 #> 0.8+12 0.19172 0.16481 0.02752 0.14010 0.69082     0.56756        0.28587     0.14657 #> 1.6+12 0.23685 0.20790 0.02896 0.16430 0.83609     0.48787        0.28715     0.22498 #> 2.4+12 0.27570 0.23836 0.02865 0.18959 0.90570     0.43039        0.27716     0.29245 #> 3.6+12 0.32825 0.27247 0.02611 0.23329 0.95521     0.36841        0.25258     0.37901 #> 5+12   0.38362 0.30255 0.02177 0.29273 0.98051     0.32100        0.21730     0.46170 #> 6+12   0.41912 0.31983 0.01832 0.33906 0.98942     0.29912        0.19269     0.50819 #>  #>  #> [[2]] #> [[2]]$`trial-A` #>          mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+0 0.26814 0.20897 0.00921 0.21871 0.75773     0.39043        0.27542     0.33415 #> 0.2+0 0.33265 0.22806 0.01631 0.29563 0.81783     0.28592        0.26153     0.45255 #> 0.4+0 0.40530 0.24731 0.02576 0.38520 0.87830     0.20253        0.22777     0.56970 #> 0.8+0 0.47981 0.26293 0.03805 0.48000 0.93033     0.14415        0.18695     0.66890 #> 1.6+0 0.55030 0.27216 0.05140 0.57280 0.96564     0.10492        0.14716     0.74792 #> 2.4+0 0.58816 0.27448 0.06003 0.62448 0.97871     0.08794        0.12830     0.78376 #> 3.6+0 0.62306 0.27480 0.06955 0.67288 0.98712     0.07452        0.11243     0.81305 #> 5+0   0.64911 0.27379 0.07744 0.70944 0.99158     0.06503        0.10179     0.83318 #> 6+0   0.66271 0.27281 0.08181 0.72818 0.99340     0.06048        0.09647     0.84305 #>  #> [[2]]$`trial-B` #>           mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+8  0.31803 0.21200 0.03883 0.27016 0.80618     0.27978        0.31595     0.40427 #> 0.2+8  0.37464 0.22757 0.04989 0.33596 0.85582     0.20259        0.28851     0.50890 #> 0.4+8  0.43947 0.24221 0.06374 0.41743 0.90237     0.14130        0.24416     0.61454 #> 0.8+8  0.50804 0.25388 0.07906 0.50597 0.94239     0.09733        0.19520     0.70747 #> 1.6+8  0.57453 0.26152 0.09346 0.59612 0.97093     0.07000        0.15119     0.77881 #> 2.4+8  0.61022 0.26465 0.09964 0.64633 0.98202     0.06004        0.13095     0.80901 #> 3.6+8  0.64223 0.26795 0.10260 0.69411 0.98938     0.05503        0.11411     0.83086 #> 5+8    0.66457 0.27211 0.09871 0.73061 0.99358     0.05467        0.10394     0.84139 #> 6+8    0.67519 0.27561 0.09326 0.74971 0.99529     0.05674        0.09900     0.84426 #> 0.1+12 0.34760 0.20579 0.06406 0.30474 0.81568     0.19935        0.34391     0.45674 #> 0.2+12 0.40176 0.22017 0.07626 0.36739 0.86299     0.14068        0.29892     0.56040 #> 0.4+12 0.46378 0.23381 0.09166 0.44455 0.90747     0.09630        0.24390     0.65980 #> 0.8+12 0.52930 0.24507 0.10814 0.52884 0.94589     0.06590        0.18934     0.74476 #> 1.6+12 0.59243 0.25375 0.11766 0.61408 0.97316     0.04924        0.14498     0.80578 #> 2.4+12 0.62561 0.25906 0.11782 0.66298 0.98376     0.04668        0.12468     0.82864 #> 3.6+12 0.65406 0.26685 0.10897 0.70973 0.99105     0.04985        0.11017     0.83998 #> 5+12   0.67204 0.27716 0.09146 0.74623 0.99504     0.05885        0.10170     0.83945 #> 6+12   0.67941 0.28518 0.07847 0.76665 0.99662     0.06699        0.09851     0.83450 #>  #>  #> [[3]] #> [[3]]$`trial-A` #>          mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+0 0.55392 0.23487 0.10672 0.56626 0.94450     0.05423        0.14813     0.79764 #> 0.2+0 0.62100 0.22417 0.15080 0.65006 0.95843     0.02823        0.09791     0.87386 #> 0.4+0 0.68267 0.21360 0.19681 0.72473 0.97135     0.01569        0.06323     0.92108 #> 0.8+0 0.73574 0.20305 0.24131 0.78820 0.98240     0.00966        0.04240     0.94794 #> 1.6+0 0.77960 0.19223 0.28604 0.83776 0.99039     0.00650        0.02952     0.96398 #> 2.4+0 0.80132 0.18580 0.30996 0.86165 0.99352     0.00502        0.02416     0.97082 #> 3.6+0 0.82049 0.17938 0.33431 0.88245 0.99573     0.00419        0.02007     0.97574 #> 5+0   0.83435 0.17421 0.35317 0.89696 0.99698     0.00354        0.01748     0.97898 #> 6+0   0.84146 0.17137 0.36365 0.90436 0.99751     0.00331        0.01605     0.98064 #>  #> [[3]]$`trial-B` #>           mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+8  0.57010 0.23870 0.11961 0.58521 0.95411     0.04638        0.14664     0.80698 #> 0.2+8  0.63093 0.22772 0.16315 0.66154 0.96590     0.02378        0.10065     0.87557 #> 0.4+8  0.68930 0.21501 0.20934 0.73289 0.97661     0.01234        0.06433     0.92333 #> 0.8+8  0.74132 0.20229 0.25455 0.79378 0.98518     0.00676        0.04188     0.95136 #> 1.6+8  0.78449 0.19122 0.29550 0.84357 0.99171     0.00438        0.02938     0.96624 #> 2.4+8  0.80505 0.18657 0.31334 0.86802 0.99443     0.00392        0.02481     0.97127 #> 3.6+8  0.82157 0.18479 0.32088 0.88878 0.99649     0.00436        0.02253     0.97311 #> 5+8    0.83121 0.18717 0.31122 0.90422 0.99773     0.00536        0.02350     0.97114 #> 6+8    0.83470 0.19080 0.29669 0.91165 0.99826     0.00665        0.02486     0.96849 #> 0.1+12 0.58885 0.22947 0.15101 0.60400 0.95623     0.02908        0.13299     0.83793 #> 0.2+12 0.64701 0.21878 0.19374 0.67685 0.96746     0.01465        0.08733     0.89802 #> 0.4+12 0.70278 0.20659 0.23872 0.74507 0.97759     0.00718        0.05475     0.93807 #> 0.8+12 0.75226 0.19485 0.28069 0.80306 0.98590     0.00414        0.03481     0.96105 #> 1.6+12 0.79252 0.18624 0.31502 0.85126 0.99229     0.00310        0.02563     0.97127 #> 2.4+12 0.81058 0.18486 0.32065 0.87471 0.99499     0.00347        0.02347     0.97306 #> 3.6+12 0.82312 0.18922 0.30377 0.89506 0.99708     0.00524        0.02505     0.96971 #> 5+12   0.82759 0.19985 0.26604 0.90954 0.99824     0.00897        0.02914     0.96189 #> 6+12   0.82713 0.20955 0.23260 0.91701 0.99876     0.01278        0.03287     0.95435 #>  #>  #> [[4]] #> [[4]]$`trial-A` #>          mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+0 0.11867 0.11368 0.00285 0.08317 0.42156     0.72987        0.20847     0.06166 #> 0.2+0 0.16832 0.14058 0.00634 0.13091 0.52177     0.57767        0.28551     0.13682 #> 0.4+0 0.23900 0.17944 0.01193 0.19939 0.66692     0.41518        0.30962     0.27520 #> 0.8+0 0.32700 0.22415 0.01969 0.28785 0.82070     0.28735        0.27547     0.43718 #> 1.6+0 0.42030 0.26144 0.02924 0.39036 0.92652     0.19896        0.22597     0.57507 #> 2.4+0 0.47251 0.27665 0.03573 0.45497 0.96065     0.16300        0.19858     0.63842 #> 3.6+0 0.52117 0.28686 0.04252 0.52053 0.97972     0.13457        0.17341     0.69202 #> 5+0   0.55754 0.29191 0.04842 0.57293 0.98840     0.11601        0.15508     0.72891 #> 6+0   0.57648 0.29364 0.05186 0.60143 0.99151     0.10739        0.14621     0.74640 #>  #> [[4]]$`trial-B` #>           mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+8  0.18628 0.13471 0.02386 0.15218 0.53638     0.52684        0.33541     0.13775 #> 0.2+8  0.23069 0.15834 0.03157 0.19210 0.63125     0.40788        0.36582     0.22630 #> 0.4+8  0.29222 0.18850 0.04234 0.24976 0.74582     0.28848        0.35725     0.35427 #> 0.8+8  0.36998 0.22202 0.05526 0.32964 0.85779     0.19335        0.30722     0.49943 #> 1.6+8  0.45580 0.25243 0.06800 0.42798 0.93786     0.13186        0.24138     0.62676 #> 2.4+8  0.50490 0.26668 0.07340 0.49072 0.96565     0.11014        0.20534     0.68452 #> 3.6+8  0.55053 0.27857 0.07551 0.55580 0.98266     0.09668        0.17413     0.72919 #> 5+8    0.58374 0.28762 0.07251 0.60975 0.99057     0.09245        0.15219     0.75536 #> 6+8    0.60032 0.29299 0.06827 0.63837 0.99357     0.09346        0.14078     0.76576 #> 0.1+12 0.22155 0.13495 0.04615 0.19109 0.56234     0.38986        0.42474     0.18540 #> 0.2+12 0.26404 0.15625 0.05524 0.22990 0.65119     0.29205        0.42655     0.28140 #> 0.4+12 0.32295 0.18402 0.06725 0.28584 0.75831     0.19990        0.38786     0.41224 #> 0.8+12 0.39743 0.21564 0.08076 0.36222 0.86533     0.13197        0.31501     0.55302 #> 1.6+12 0.47953 0.24583 0.09131 0.45613 0.94205     0.09378        0.23702     0.66920 #> 2.4+12 0.52616 0.26162 0.09122 0.51759 0.96925     0.08418        0.19670     0.71912 #> 3.6+12 0.56861 0.27725 0.08313 0.58244 0.98505     0.08485        0.16344     0.75171 #> 5+12   0.59812 0.29156 0.06918 0.63659 0.99265     0.09321        0.14154     0.76525 #> 6+12   0.61195 0.30077 0.05775 0.66487 0.99528     0.10149        0.13108     0.76743 #>  #>  #> [[5]] #> [[5]]$`trial-A` #>          mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+0 0.24977 0.15939 0.02780 0.22110 0.62143     0.34596        0.37606     0.27798 #> 0.2+0 0.33372 0.17764 0.05234 0.31479 0.71227     0.18186        0.34897     0.46917 #> 0.4+0 0.43305 0.20155 0.08178 0.42542 0.82251     0.09285        0.24353     0.66362 #> 0.8+0 0.53212 0.22284 0.11275 0.53840 0.91761     0.05181        0.16035     0.78784 #> 1.6+0 0.61830 0.23384 0.14357 0.64406 0.96940     0.03166        0.10776     0.86058 #> 2.4+0 0.66103 0.23540 0.16184 0.69932 0.98398     0.02440        0.08762     0.88798 #> 3.6+0 0.69831 0.23419 0.17950 0.74859 0.99171     0.01909        0.07211     0.90880 #> 5+0   0.72486 0.23168 0.19371 0.78465 0.99524     0.01579        0.06265     0.92156 #> 6+0   0.73833 0.22983 0.20204 0.80272 0.99649     0.01458        0.05739     0.92803 #>  #> [[5]]$`trial-B` #>           mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+8  0.30531 0.17914 0.05170 0.27246 0.72103     0.23654        0.37864     0.38482 #> 0.2+8  0.37687 0.19477 0.07589 0.35207 0.79578     0.13470        0.32380     0.54150 #> 0.4+8  0.46261 0.20991 0.10754 0.45071 0.87398     0.06770        0.23520     0.69710 #> 0.8+8  0.55273 0.22218 0.14098 0.55828 0.93669     0.03485        0.15359     0.81156 #> 1.6+8  0.63459 0.22940 0.17217 0.66147 0.97464     0.02033        0.10184     0.87783 #> 2.4+8  0.67517 0.23175 0.18515 0.71663 0.98638     0.01719        0.08428     0.89853 #> 3.6+8  0.70923 0.23440 0.19008 0.76608 0.99316     0.01686        0.07215     0.91099 #> 5+8    0.73142 0.23858 0.18203 0.80303 0.99632     0.01876        0.06757     0.91367 #> 6+8    0.74133 0.24245 0.17331 0.82163 0.99746     0.02162        0.06618     0.91220 #> 0.1+12 0.33556 0.17496 0.07780 0.30647 0.73527     0.15761        0.39127     0.45112 #> 0.2+12 0.40400 0.18910 0.10365 0.38218 0.80682     0.08480        0.31265     0.60255 #> 0.4+12 0.48600 0.20300 0.13593 0.47605 0.88037     0.04084        0.21272     0.74644 #> 0.8+12 0.57204 0.21483 0.16929 0.57851 0.94061     0.02066        0.13542     0.84392 #> 1.6+12 0.64954 0.22356 0.19358 0.67816 0.97648     0.01398        0.09136     0.89466 #> 2.4+12 0.68696 0.22877 0.19789 0.73125 0.98777     0.01420        0.07767     0.90813 #> 3.6+12 0.71663 0.23699 0.18356 0.78005 0.99423     0.01835        0.07137     0.91028 #> 5+12   0.73360 0.24843 0.15551 0.81524 0.99711     0.02646        0.07069     0.90285 #> 6+12   0.73972 0.25748 0.13210 0.83393 0.99815     0.03410        0.07095     0.89495 #>  #>  #> [[6]] #> [[6]]$`trial-A` #>          mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+0 0.05911 0.06818 0.00063 0.03493 0.24966     0.91423        0.07783     0.00794 #> 0.2+0 0.09033 0.08776 0.00215 0.06284 0.32539     0.82261        0.15384     0.02355 #> 0.4+0 0.14489 0.12307 0.00565 0.11133 0.45913     0.64384        0.26451     0.09165 #> 0.8+0 0.23176 0.18129 0.01172 0.18675 0.67629     0.43971        0.30121     0.25908 #> 1.6+0 0.34174 0.24353 0.01977 0.29132 0.87424     0.28997        0.26181     0.44822 #> 2.4+0 0.40748 0.27144 0.02508 0.36426 0.94082     0.23060        0.22948     0.53992 #> 3.6+0 0.46949 0.29098 0.03067 0.44250 0.97390     0.18543        0.19892     0.61565 #> 5+0   0.51563 0.30114 0.03564 0.50778 0.98694     0.15717        0.17738     0.66545 #> 6+0   0.53948 0.30490 0.03865 0.54403 0.99138     0.14457        0.16604     0.68939 #>  #> [[6]]$`trial-B` #>           mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+8  0.13106 0.09683 0.01567 0.10728 0.37996     0.70805        0.24788     0.04407 #> 0.2+8  0.16116 0.11591 0.02119 0.13268 0.46257     0.60029        0.31297     0.08674 #> 0.4+8  0.21043 0.14603 0.02984 0.17527 0.58846     0.45174        0.36967     0.17859 #> 0.8+8  0.28621 0.18952 0.04152 0.24147 0.75561     0.30389        0.35784     0.33827 #> 1.6+8  0.38493 0.23782 0.05464 0.33850 0.90060     0.19503        0.29274     0.51223 #> 2.4+8  0.44619 0.26221 0.06073 0.40829 0.95072     0.15516        0.24764     0.59720 #> 3.6+8  0.50464 0.28184 0.06339 0.48516 0.97848     0.13016        0.20631     0.66353 #> 5+8    0.54764 0.29489 0.06066 0.55205 0.98990     0.12065        0.17545     0.70390 #> 6+8    0.56929 0.30157 0.05736 0.58970 0.99353     0.11880        0.15963     0.72157 #> 0.1+12 0.16861 0.10178 0.03547 0.14699 0.42186     0.55455        0.37150     0.07395 #> 0.2+12 0.19744 0.11826 0.04245 0.17231 0.49480     0.45280        0.42021     0.12699 #> 0.4+12 0.24468 0.14532 0.05306 0.21371 0.61089     0.32741        0.43966     0.23293 #> 0.8+12 0.31742 0.18591 0.06541 0.27818 0.76967     0.21384        0.38958     0.39658 #> 1.6+12 0.41223 0.23284 0.07658 0.37137 0.90767     0.14039        0.29564     0.56397 #> 2.4+12 0.47085 0.25807 0.07755 0.44007 0.95526     0.11903        0.24141     0.63956 #> 3.6+12 0.52609 0.28065 0.07099 0.51750 0.98145     0.11237        0.19308     0.69455 #> 5+12   0.56553 0.29818 0.05881 0.58437 0.99198     0.11701        0.16055     0.72244 #> 6+12   0.58456 0.30825 0.04911 0.62246 0.99526     0.12328        0.14559     0.73113 #>  #>  #> [[7]] #> [[7]]$`trial-A` #>          mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+0 0.04107 0.04924 0.00043 0.02345 0.17909     0.96468        0.03372     0.00160 #> 0.2+0 0.06287 0.06327 0.00156 0.04278 0.23383     0.91703        0.07808     0.00489 #> 0.4+0 0.10298 0.09030 0.00423 0.07765 0.33752     0.78440        0.18784     0.02776 #> 0.8+0 0.17426 0.14502 0.00872 0.13480 0.54760     0.57015        0.28477     0.14508 #> 1.6+0 0.27667 0.21783 0.01473 0.21921 0.80490     0.38519        0.28245     0.33236 #> 2.4+0 0.34253 0.25489 0.01879 0.28040 0.90423     0.30748        0.25768     0.43484 #> 3.6+0 0.40680 0.28307 0.02328 0.34997 0.95731     0.24851        0.22889     0.52260 #> 5+0   0.45561 0.29927 0.02711 0.41235 0.97881     0.21277        0.20469     0.58254 #> 6+0   0.48110 0.30597 0.02927 0.44877 0.98594     0.19524        0.19310     0.61166 #>  #> [[7]]$`trial-B` #>           mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+8  0.11369 0.08215 0.01366 0.09462 0.32360     0.77678        0.20059     0.02263 #> 0.2+8  0.13562 0.09562 0.01829 0.11356 0.37909     0.69106        0.26402     0.04492 #> 0.4+8  0.17336 0.12013 0.02564 0.14466 0.48312     0.55616        0.34117     0.10267 #> 0.8+8  0.23644 0.16176 0.03527 0.19611 0.65544     0.39261        0.37683     0.23056 #> 1.6+8  0.32773 0.21739 0.04580 0.27414 0.84625     0.25927        0.33264     0.40809 #> 2.4+8  0.38855 0.24900 0.05067 0.33365 0.92292     0.20827        0.28655     0.50518 #> 3.6+8  0.44901 0.27590 0.05227 0.40395 0.96624     0.17497        0.23832     0.58671 #> 5+8    0.49494 0.29417 0.05008 0.46720 0.98430     0.15997        0.20190     0.63813 #> 6+8    0.51859 0.30336 0.04690 0.50519 0.99022     0.15582        0.18457     0.65961 #> 0.1+12 0.15221 0.08991 0.03285 0.13417 0.37594     0.61827        0.33582     0.04591 #> 0.2+12 0.17321 0.10106 0.03870 0.15281 0.42447     0.53061        0.39281     0.07658 #> 0.4+12 0.20941 0.12245 0.04733 0.18385 0.51609     0.41087        0.44202     0.14711 #> 0.8+12 0.27006 0.16073 0.05769 0.23394 0.67608     0.28076        0.42922     0.29002 #> 1.6+12 0.35803 0.21441 0.06621 0.31123 0.85821     0.18857        0.34417     0.46726 #> 2.4+12 0.41660 0.24654 0.06669 0.37020 0.93059     0.15941        0.28329     0.55730 #> 3.6+12 0.47438 0.27603 0.05989 0.44150 0.97139     0.14850        0.22411     0.62739 #> 5+12   0.51736 0.29837 0.04842 0.50651 0.98789     0.15118        0.18277     0.66605 #> 6+12   0.53878 0.31060 0.04001 0.54503 0.99295     0.15636        0.16319     0.68045 #>  #>  #> [[8]] #> [[8]]$`trial-A` #>          mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+0 0.03306 0.04007 0.00032 0.01892 0.14553     0.98176        0.01781     0.00043 #> 0.2+0 0.05178 0.05267 0.00120 0.03502 0.19503     0.95110        0.04730     0.00160 #> 0.4+0 0.08759 0.07862 0.00340 0.06522 0.29536     0.84184        0.14363     0.01453 #> 0.8+0 0.15450 0.13497 0.00728 0.11586 0.51412     0.62893        0.26020     0.11087 #> 1.6+0 0.25497 0.21270 0.01266 0.19266 0.79321     0.43361        0.27358     0.29281 #> 2.4+0 0.32107 0.25277 0.01640 0.25071 0.90094     0.34750        0.25593     0.39657 #> 3.6+0 0.38635 0.28352 0.02024 0.31869 0.95758     0.28067        0.23195     0.48738 #> 5+0   0.43636 0.30143 0.02354 0.38032 0.97980     0.24004        0.20898     0.55098 #> 6+0   0.46261 0.30893 0.02567 0.41675 0.98673     0.22006        0.19818     0.58176 #>  #> [[8]]$`trial-B` #>           mean      sd  q.2.5%   q.50% q.97.5% P([0,0.16)) P([0.16,0.33)) P([0.33,1]) #> 0.1+8  0.09138 0.06342 0.01104 0.07747 0.25118     0.86816        0.12625     0.00559 #> 0.2+8  0.10884 0.07303 0.01509 0.09309 0.29139     0.79879        0.18753     0.01368 #> 0.4+8  0.14135 0.09474 0.02144 0.12001 0.38402     0.66708        0.28553     0.04739 #> 0.8+8  0.20064 0.14033 0.03054 0.16548 0.57193     0.48151        0.36203     0.15646 #> 1.6+8  0.29220 0.20583 0.03981 0.23645 0.81067     0.32176        0.33846     0.33978 #> 2.4+8  0.35528 0.24340 0.04414 0.29253 0.90788     0.25585        0.29750     0.44665 #> 3.6+8  0.41885 0.27509 0.04554 0.35960 0.96243     0.21052        0.25397     0.53551 #> 5+8    0.46762 0.29589 0.04289 0.42272 0.98343     0.18912        0.21588     0.59500 #> 6+8    0.49297 0.30599 0.04019 0.46165 0.98977     0.18203        0.19545     0.62252 #> 0.1+12 0.12938 0.07330 0.02905 0.11540 0.30764     0.72073        0.26244     0.01683 #> 0.2+12 0.14614 0.08079 0.03421 0.13107 0.34354     0.63959        0.32973     0.03068 #> 0.4+12 0.17738 0.09910 0.04212 0.15809 0.42293     0.50796        0.41295     0.07909 #> 0.8+12 0.23449 0.14065 0.05171 0.20333 0.59697     0.35318        0.43979     0.20703 #> 1.6+12 0.32294 0.20356 0.05913 0.27372 0.82331     0.23534        0.36822     0.39644 #> 2.4+12 0.38392 0.24123 0.05927 0.32939 0.91729     0.19522        0.30568     0.49910 #> 3.6+12 0.44512 0.27499 0.05315 0.39748 0.96792     0.17594        0.24301     0.58105 #> 5+12   0.49138 0.29939 0.04260 0.46209 0.98670     0.17329        0.19647     0.63024 #> 6+12   0.51482 0.31231 0.03513 0.50208 0.99235     0.17616        0.17270     0.65114 #>  #>  #> attr(,\"rng\") #> attr(,\"rng\")[[1]] #> [1]       10407  2133139108  -773071531  -244150766 -1207652757  1191582384  1240354545 #>  #> attr(,\"doRNG_version\") #> [1] \"1.7.4\""},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"simulating-dose-finding-trials-with-sim_jointblrm","dir":"Articles","previous_headings":"","what":"Simulating dose-finding trials with sim_jointBLRM","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"Simulations trials usually aim estimate operating characteristics (OC) dose-finding trial design, includes e.g. ratio MTDs declared dose (doses DLT rate specific dosing interval), number patients per dose number DLTs trial, well metrics simulation results. estimate operating characteristics BLRM, one usually uses simulated trials. , one assumes fixed set available dose levels fixed dose-toxicity scenario – .e. specification DLT rate available dose level – simulates number trials setting. allows e.g. estimate average number MTDs correct interval number patients treated overly toxic doses specific dose-toxicity scenario. course possible test possible dose-toxicity scenarios, one typically confine oneself selected number scenarios illustrate different possible cases. usually range scenarios follow prior expectations, extreme scenarios assume involved drugs considerably (less) toxic expected prior, scenarios deliberately assume trials result heterogeneous data true dose-toxicity relationship follow logistic model BLRM (.e. one assumes BLRM misspecified). example simulations can performed via sim_jointBLRM, consider setting previous section. , recall monotherapy combination therapy trial shall run (partially) parallel, wanted consider dose levels given variable doses..interest use data historical trial given historical.data argument. function sim_jointBLRM supports simulation (parallel) monotherapy combination therapy trials. Internally, differentiated three types, namely monotherapy compound 1 (\"mono1\"), monotherapy compound 2 (\"mono2\"), combination therapy compounds 1 2 (\"combi\"). types, function can actively simulate 2 trials (.e., six parallel trials total), order cohorts enrolled six trials can specified freely. simulated trials can activated independently , .e. one can choose many parallel trials simulated. Additionally, historical data arbitrarily many trials already concluded can given, furthermore, data observed actively simulated trials start simulation can included well (allows simulate one trials might continue already observed specific data scenario).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"naming-conventions-for-sim_jointblrm","dir":"Articles","previous_headings":"Simulating dose-finding trials with sim_jointBLRM","what":"Naming conventions for sim_jointBLRM","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"function features large number optional parameters allow relatively flexible customization simulated trials, e.g. regarding number patients per cohort, criteria MTD selection, escalation rules, topics. Refer documentation detail parameters discussed vignette. allow settings deviate across simulated trials, many arguments sim_jointBLRM exist six variations, one simulated trial. differentiate , arguments feature trial-specific suffixes given following table. , first second trial specific trial type mean simply independently escalating trials type, imply specific order dependency across first second trial (except jointly modeled BLRM). instance possible just simulate mono2.b trial deactivate trials. take away message naming conventions one needs use parameter corresponding suffix specific option shall affect one specific trial others. Arguments suffix general always affect simulated trials. Apart argument names, suffixes six potentially simulated trials also used refer corresponding trial order trials enroll cohorts specified. Furthermore, also used encode trials historical data previously recorded actively simulated trial shall included. Refer documentation detail.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"configuring-the-trial-simulations","dir":"Articles","previous_headings":"Simulating dose-finding trials with sim_jointBLRM","what":"Configuring the trial simulations","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"First foremost, one needs decide possible six trials need simulated activate corresponding trials. example vignette, monotherapy trial compound 1 combination therapy trial shall included. assume chosen utilize mono1.combi.trials represent trials (although equivalent use mono1.b combi.b trials even combination mono1.b combi.). activate trials, can supply arguments Now, specify corresponding available dose levels. , use doses specified previously: Note doses.mono1.vector, doses.combi.needs matrix two rows, column specifies dose combination considered combination therapy trial. code generated every possible combination doses monotherapy trial compound 1 doses 8 12 compound 2. function scenario_jointBLRM, one needs specify reference doses prior distribution BLRM. , argument names formats scenario_jointBLRM used, .e. arguments dose.ref1, dose.ref2, prior.mu, prior.tau can used form specified previous section. holds historical data, assume observations used, namely Additionally, need provide starting dose levels activated trials. Note must elements set available dose levels, otherwise function report error. assume monotherapy trial start lowest available dose, 0.1, specified via later assume additionally monotherapy trial enrolls least 3 4 cohorts first combination therapy cohort processed, due , assume combination trial use slightly larger starting dose. instance, suppose combination therapy shall begin dose combination 0.2 compound 1 8 compound 2. expressed using Note two arguments need specified , suffix .combi.a1 first compound .combi.a2 second compound. arguments belong combi.trial, endings .a1 .a2 used differentiate setting first second compound combi.trial. also used arguments may need different settings two combination therapy partners combination therapy trial.","code":"active.mono1.a = TRUE active.combi.a = TRUE doses.mono1.a = c(0.1, 0.2, 0.4, 0.8, 1.6, 2.4, 3.6, 5, 6)  doses.combi.a = rbind(   rep(doses.mono1.a, times=2),   rep(c(8, 12),      each = length(doses.mono1.a))) historical.data #> $dose1 #> [1] 0 0 0 0 0 #>  #> $dose2 #> [1]  2  4  8 12 16 #>  #> $n.pat #> [1]  3  3  3  9 12 #>  #> $n.dlt #> [1] 0 0 0 1 2 #>  #> $trial #> [1] \"H1\" \"H1\" \"H1\" \"H1\" \"H1\" start.dose.mono1.a = 0.1 start.dose.combi.a1 = 0.2 start.dose.combi.a2 = 8"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"optional-general-specification","dir":"Articles","previous_headings":"Simulating dose-finding trials with sim_jointBLRM > Configuring the trial simulations","what":"Optional general specification","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"next step, general course trial can defined, consisting number patients per cohort, maximum number patients trial, order cohorts enrolled. arguments optional, relatively sensible defaults used specified. First, set number patients per cohort, one can use e.g. Note cohort.size global variant argument, .e. affects simulated trials. provided explicitly, function use default value 3. specific trial shall deviate value, one can use trial-specific parameter corresponding trial suffix, e.g. Note affect mono1.b trial, plan simulate current example. mono1.combi.trial, want simulate, global cohort size 3 still effect. apply cohort.size given function, default value used case. One can also provide vector multiple cohort sizes, case function randomly select one given cohort sizes cohort. cohort sizes drawn uniformly random possible numbers specified ‘cohort.size’ options given. desired draw cohort size specific probability, one can use optional argument cohort.prob provide probability cohort size, e.g. setting example, mono1.b trial select size cohort randomly according corresponding probabilities, .e. cohort size 2 drawn probability 0.05, size 3 probability 0.85, cohort size 4 chosen probability 0.1. , global trial-specific version argument cohort.prob. next step, want set maximum number patients trial. assume maximum number patients 36 combination therapy trial 45 monotherapy trial. can set via trial-specific arguments Note also global argument max.n, used example. Now, order cohorts enrolled specified. , function uses argument cohort.queue, provides, name says, queue cohorts processed simulation. can done supplying simple pattern automatically repeated (note however function drop warning case) supplying complex pattern already contains every cohort may potentially arriving throughout trial. instance, simply simulate cohorts mono1.combi.alternately, one can use order repeated trials concluded due stopped early, found MTD, reaching maximum patient number. cohort queue mostly used enforce specific order cohorts trial. , consider example previous section, monotherapy combination trial shall simulated parallel. Assume instance one wants start combination therapy trial first four monotherapy cohorts processed, , afterwards, trials shall enroll cohorts alternately. expressed setting queue Note c(\"mono1.\", \"combi.\") repeated 12 times, translates 12 \"combi.\" 15 \"mono1.\" cohorts queue. cohort size previously set 3 patients, results total 36 patients combi.queue 45 patients mono1., .e. precisely maximum sample size specified. ensures function need repeat queue automatically. Note problem provide cohort queue containing patients required, function simply ignore cohorts simulated trial concluded. Therefore, also possible use e.g. , supplied much cohorts needed (100 combination therapy), still equivalent previous queue. supplying lower numbers cohorts cause function operate differently, repeat cohort queue trials concluded. Note trials cohort queue can also indicated numbers (usually leads shorter code full trial names), stated following table. Hence, previous cohort queue equivalently written ","code":"cohort.size = 3 cohort.size.mono1.b = 4 cohort.size.mono1.b = c(2,    3,    4) cohort.prob.mono1.b = c(0.05, 0.85, 0.1) max.n.mono1.a = 45 max.n.combi.a = 36 cohort.queue = c(\"mono1.a\", \"combi.a\") cohort.queue = c(\"mono1.a\", \"mono1.a\", \"mono1.a\", rep(c(\"mono1.a\", \"combi.a\"),                                                       times=12)) head(cohort.queue, 9) #> [1] \"mono1.a\" \"mono1.a\" \"mono1.a\" \"mono1.a\" \"combi.a\" \"mono1.a\" \"combi.a\" \"mono1.a\" \"combi.a\" cohort.queue = c(\"mono1.a\", \"mono1.a\", \"mono1.a\", rep(c(\"mono1.a\", \"combi.a\"),                                                       times=100)) cohort.queue = c(1, 1, 1, rep(c(1, 3), times=100))"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"escalation-decisions-in-simulted-trials","dir":"Articles","previous_headings":"Simulating dose-finding trials with sim_jointBLRM > Configuring the trial simulations","what":"Escalation decisions in simulted trials","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"next step, specify rules dose escalation decisions. mentioned , function default apply EWOC-based escalation, means doses can chosen posterior probability overdosing 0.25. boundary also altered, using argument EWOC states upper boundary, function afterwards maximize probability DLT rate within target interval among doses satisfy EWOC. still leads multiple possible doses, function subsequently maximize dose first compound among doses probability target dosing. maximize second compound instead, one can set argument esc.comp.max, may values 1 2 indicates component function maximize case draws. Note one can also deviate maximizing target probability maximize directly dose among levels satisfy EWOC, covered vignette. Refer documentation argument esc.rule information . Neuenschwander et al. (2014) recommend impose maximum increment dose additionally EWOC, order avoid overly large dosing steps dose escalations. can realized using esc.step family arguments, available global variant six trial-specific parameters. escalation step interpreted maximum factor dose escalation. instance, escalation step set value 2, dose can doubled escalation decision. escalation step given, function set maximum factor subsequent dose levels additional constrain escalation. However, might situations one may want fixed maximum factor escalations, e.g. factor express increments planned dose levels. Consider instance trial planned doses 10, 20, 30, 40 mg. order allow escalating 10 20, escalation step need set 2, also allow escalating 20 40 without enrolling patients 30. prevent , one can set argument constrains escalations given set dose levels, .e. next larger prespecified dose can used. activated, esc.constrain causes function ignore given escalation step always restrict escalation decisions next larger dose (pose boundary deescalating dose). , esc.constrain global variant, additional arguments like esc.constrain.mono1.b affect corresponding trial.","code":"ewoc.threshold = 0.25 esc.constrain = TRUE"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"mtd-selection","dir":"Articles","previous_headings":"Simulating dose-finding trials with sim_jointBLRM > Configuring the trial simulations","what":"MTD selection","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"now remains specify rules MTD selection trial. two different arguments control function selects MTD simulated trial, namely mtd.decision mtd.enforce. available global arguments without suffix trial-specific argument corresponding suffix. argument mtd.decision named list five entries form list stated also default argument. first four list entries correspond demanded boundaries four different conditions used determine MTD. last entry, mtd.decision$rule pose condition , dictates conditions mandatory instead. simulation, MTD can determined dose used last cohort, always current candidate MTD. MTD selection, function first demand current dose level also recommended next cohort (-called stabilization criterion). case, check whether current dose also satisfies conditions determined mtd.decision, , satisfied, declare current dose MTD trial. precise conditions corresponding entries mtd.decision listed following table. terms effect entry rule, following possibilities supported rule 1: Conditions 1 2 necessary, least one conditions 3 4 must satisfied well. rule 2: Conditions 1 3 necessary, least one conditions 2 4 must satisfied well. decision rule specifications may supported future. second argument affects MTD selection, mtd.enforce, logical value controls function behaves trial reaches specified maximum sample size. default, mtd.enforce FALSE, causes trials reach maximum sample size considered found MTD, also noted output. parameter instead TRUE, current dose considered MTD maximum sample size reached conditions MTD selections satisfied. can e.g. used one wants approximate average dosing recommendations specific number cohorts based simulations. instance, max.n = 15, mtd.enforce = TRUE, one can set mtd.decision values reached within 15 patients (e.g., mtd.decision$rule = 2 mtd.decision$min.pat = 16), function simply report dosing recommendation 15 patients MTD apply MTD decision rule. option can also set individual trials (via parameters corresponding suffix).","code":"mtd.decision = list(   min.dlt     = 1,   pat.at.mtd  = 6,   min.pat     = 12,   target.prob = 0.5,   rule        = 2 )"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"dose-toxicity-scenarios-and-trial-simulations","dir":"Articles","previous_headings":"Simulating dose-finding trials with sim_jointBLRM > Configuring the trial simulations","what":"Dose-toxicity scenarios and trial simulations","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"remains specify dose-toxicity scenario simulation can started. , DLT rate dose level assumed, used function simulate number patients experiencing DLT cohort. arguments specifying DLT rate one simulated trials named according pattern tox.[...], [...] can trial-specific suffixes. Note global variant argument. situation discussed previous chapters, required arguments therefore tox.mono1.tox.combi.. First, recall specification dose levels monotherapy trial: DLT rates (toxicities) must therefore specified 9 dose levels. done supplying vector length, entry tox.mono1.[] specifies DLT rate dose given doses.mono1.[]. case, e.g. Similarly, combination therapy trial, dose levels given , column specifies dose, argument tox.combi.needs one entry column, .e. 18 entries example. Similarly , entry argument provides DLT rate dose given column doses.combi.. Hence, dose-toxicity scenario case Note one usually consider multiple different dose toxicity scenarios assess performance prior different settings situations. following, consider scenario specified simplicity. completes setup specification trials simulated. last step, remains specify number simulated studies via parameter n.studies. example, 1 study used following. Note however course far sufficient proper evaluation prior, one simulate something around order e.g. 1000 10000 studies. However, aware depending specifications, study require multiple minutes run time repeated calls Stan, 1000 trials may take multiple hours even nearly day simulate. therefore recommended run simulation parallel. cluster available, parallel backend consisting multiple nodes multiple cores can registered, function can leverage capabilities cluster nested foreach loop. however purely optional. , running simulations parallel moderate number cores, recommended consider argument working.path documentation, allows save reload MCMC results across nodes cores. last, one can also optionally specify arguments path file.name, cause function automatically write summarized simulation results .xlsx file specified name specified path. Otherwise, simulation results returned R. Putting previous explanations together, call sim_jointBLRM therefore : completes setup simulation function prior evaluations. mentioned , recommended evaluate multiple different scenarios least multiple hundred studies assessing performance actual design.","code":"doses.mono1.a #> [1] 0.1 0.2 0.4 0.8 1.6 2.4 3.6 5.0 6.0 #Compound 1:     0.1   0.2   0.4   0.8   1.6   2.4   3.6   5     6 tox.mono1.a = c(0.01, 0.02, 0.03, 0.05, 0.09, 0.12, 0.19, 0.29, 0.43) doses.combi.a #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16] [,17] [,18] #> [1,]  0.1  0.2  0.4  0.8  1.6  2.4  3.6    5    6   0.1   0.2   0.4   0.8   1.6   2.4   3.6     5     6 #> [2,]  8.0  8.0  8.0  8.0  8.0  8.0  8.0    8    8  12.0  12.0  12.0  12.0  12.0  12.0  12.0    12    12 #Compound 1:     0.1   0.2   0.4   0.8   1.6   2.4   3.6   5     6        0.1   0.2   0.4   0.8   1.6   2.4   3.6   5     6 #compound 2:     8     8     8     8     8     8     8     8     8        12    12    12    12    12    12    12    12    12 tox.combi.a = c(0.02, 0.03, 0.04, 0.08, 0.14, 0.21, 0.32, 0.39, 0.47,    0.04, 0.06, 0.09, 0.12, 0.17, 0.29, 0.45, 0.52, 0.61) sim_result <- sim_jointBLRM(   active.mono1.a = TRUE,   active.combi.a = TRUE,    doses.mono1.a = doses.mono1.a,   doses.combi.a = doses.combi.a,   dose.ref1 = dose.ref1,   dose.ref2 = dose.ref2,   start.dose.mono1.a = start.dose.mono1.a,   start.dose.combi.a1 = start.dose.combi.a1,   start.dose.combi.a2 = start.dose.combi.a2,    tox.mono1.a = tox.mono1.a,   tox.combi.a = tox.combi.a,    historical.data = historical.data,   prior.mu = prior.mu,   prior.tau = prior.tau,    max.n.mono1.a = max.n.mono1.a,   max.n.combi.a = max.n.combi.a,   cohort.size = cohort.size,   cohort.queue = cohort.queue,   ewoc.threshold = ewoc.threshold,   esc.constrain = esc.constrain,   mtd.decision = mtd.decision,    n.studies = 1 )  print(sim_result) #> $`results combi.a` #>                              underdose target dose overdose max n reached before MTD all doses too toxic #> Number of trials                     0           1        0                        0                   0 #> Percentage                           0         100        0                        0                   0 #> Percentage not all too toxic         0         100        0                        0                  NA #>  #> $`summary combi.a` #>                      Median       Mean       Min.       Max.       2.5%      97.5% #> #Pat underdose    9.0000000  9.0000000  9.0000000  9.0000000  9.0000000  9.0000000 #> #Pat target dose  6.0000000  6.0000000  6.0000000  6.0000000  6.0000000  6.0000000 #> #Pat overdose     0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 #> #Pat (all)       15.0000000 15.0000000 15.0000000 15.0000000 15.0000000 15.0000000 #> #DLT underdose    1.0000000  1.0000000  1.0000000  1.0000000  1.0000000  1.0000000 #> #DLT target dose  1.0000000  1.0000000  1.0000000  1.0000000  1.0000000  1.0000000 #> #DLT overdose     0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 #> #DLT (all)        2.0000000  2.0000000  2.0000000  2.0000000  2.0000000  2.0000000 #> % overdose        0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 #> % DLT             0.1333333  0.1333333  0.1333333  0.1333333  0.1333333  0.1333333 #>  #> $`MTDs combi.a` #>                  0.1+8       0.2+8       0.4+8       0.8+8       1.6+8       2.4+8         3.6+8         5+8        #> Dose             \"0.1+8\"     \"0.2+8\"     \"0.4+8\"     \"0.8+8\"     \"1.6+8\"     \"2.4+8\"       \"3.6+8\"       \"5+8\"      #> True P(DLT)      \"0.02\"      \"0.03\"      \"0.04\"      \"0.08\"      \"0.14\"      \"0.21\"        \"0.32\"        \"0.39\"     #> True category    \"underdose\" \"underdose\" \"underdose\" \"underdose\" \"underdose\" \"target dose\" \"target dose\" \"overdose\" #> MTD declared (n) \"0\"         \"0\"         \"0\"         \"0\"         \"0\"         \"0\"           \"0\"           \"0\"        #>                  6+8        0.1+12      0.2+12      0.4+12      0.8+12      1.6+12        2.4+12        3.6+12     #> Dose             \"6+8\"      \"0.1+12\"    \"0.2+12\"    \"0.4+12\"    \"0.8+12\"    \"1.6+12\"      \"2.4+12\"      \"3.6+12\"   #> True P(DLT)      \"0.47\"     \"0.04\"      \"0.06\"      \"0.09\"      \"0.12\"      \"0.17\"        \"0.29\"        \"0.45\"     #> True category    \"overdose\" \"underdose\" \"underdose\" \"underdose\" \"underdose\" \"target dose\" \"target dose\" \"overdose\" #> MTD declared (n) \"0\"        \"0\"         \"0\"         \"0\"         \"0\"         \"0\"           \"1\"           \"0\"        #>                  5+12       6+12       #> Dose             \"5+12\"     \"6+12\"     #> True P(DLT)      \"0.52\"     \"0.61\"     #> True category    \"overdose\" \"overdose\" #> MTD declared (n) \"0\"        \"0\"        #>  #> $`#pat. combi.a` #>             0.1+8   0.2+8   0.4+8   0.8+8   1.6+8   2.4+8   3.6+8   5+8   6+8   0.1+12   0.2+12   0.4+12   0.8+12   #> Dose        \"0.1+8\" \"0.2+8\" \"0.4+8\" \"0.8+8\" \"1.6+8\" \"2.4+8\" \"3.6+8\" \"5+8\" \"6+8\" \"0.1+12\" \"0.2+12\" \"0.4+12\" \"0.8+12\" #> mean #pat   \"0\"     \"3\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"   \"0\"   \"0\"      \"0\"      \"3\"      \"3\"      #> median #pat \"0\"     \"3\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"   \"0\"   \"0\"      \"0\"      \"3\"      \"3\"      #> min #pat    \"0\"     \"3\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"   \"0\"   \"0\"      \"0\"      \"3\"      \"3\"      #> max #pat    \"0\"     \"3\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"   \"0\"   \"0\"      \"0\"      \"3\"      \"3\"      #>             1.6+12   2.4+12   3.6+12   5+12   6+12   #> Dose        \"1.6+12\" \"2.4+12\" \"3.6+12\" \"5+12\" \"6+12\" #> mean #pat   \"3\"      \"3\"      \"0\"      \"0\"    \"0\"    #> median #pat \"3\"      \"3\"      \"0\"      \"0\"    \"0\"    #> min #pat    \"3\"      \"3\"      \"0\"      \"0\"    \"0\"    #> max #pat    \"3\"      \"3\"      \"0\"      \"0\"    \"0\"    #>  #> $`#DLT combi.a` #>             0.1+8   0.2+8   0.4+8   0.8+8   1.6+8   2.4+8   3.6+8   5+8   6+8   0.1+12   0.2+12   0.4+12   0.8+12   #> Dose        \"0.1+8\" \"0.2+8\" \"0.4+8\" \"0.8+8\" \"1.6+8\" \"2.4+8\" \"3.6+8\" \"5+8\" \"6+8\" \"0.1+12\" \"0.2+12\" \"0.4+12\" \"0.8+12\" #> mean #DLT   \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"   \"0\"   \"0\"      \"0\"      \"0\"      \"1\"      #> median #DLT \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"   \"0\"   \"0\"      \"0\"      \"0\"      \"1\"      #> min #DLT    \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"   \"0\"   \"0\"      \"0\"      \"0\"      \"1\"      #> max #DLT    \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"     \"0\"   \"0\"   \"0\"      \"0\"      \"0\"      \"1\"      #>             1.6+12   2.4+12   3.6+12   5+12   6+12   #> Dose        \"1.6+12\" \"2.4+12\" \"3.6+12\" \"5+12\" \"6+12\" #> mean #DLT   \"0\"      \"1\"      \"0\"      \"0\"    \"0\"    #> median #DLT \"0\"      \"1\"      \"0\"      \"0\"    \"0\"    #> min #DLT    \"0\"      \"1\"      \"0\"      \"0\"    \"0\"    #> max #DLT    \"0\"      \"1\"      \"0\"      \"0\"    \"0\"    #>  #> $`results mono1.a` #>                              underdose target dose overdose max n reached before MTD all doses too toxic #> Number of trials                     0           1        0                        0                   0 #> Percentage                           0         100        0                        0                   0 #> Percentage not all too toxic         0         100        0                        0                  NA #>  #> $`summary mono1.a` #>                      Median       Mean       Min.       Max.       2.5%      97.5% #> #Pat underdose   21.0000000 21.0000000 21.0000000 21.0000000 21.0000000 21.0000000 #> #Pat target dose  6.0000000  6.0000000  6.0000000  6.0000000  6.0000000  6.0000000 #> #Pat overdose     0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 #> #Pat (all)       27.0000000 27.0000000 27.0000000 27.0000000 27.0000000 27.0000000 #> #DLT underdose    1.0000000  1.0000000  1.0000000  1.0000000  1.0000000  1.0000000 #> #DLT target dose  2.0000000  2.0000000  2.0000000  2.0000000  2.0000000  2.0000000 #> #DLT overdose     0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 #> #DLT (all)        3.0000000  3.0000000  3.0000000  3.0000000  3.0000000  3.0000000 #> % overdose        0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 #> % DLT             0.1111111  0.1111111  0.1111111  0.1111111  0.1111111  0.1111111 #>  #> $`MTDs mono1.a` #>                  0.1         0.2         0.4         0.8         1.6         2.4         3.6           5             #> Dose             \"0.1\"       \"0.2\"       \"0.4\"       \"0.8\"       \"1.6\"       \"2.4\"       \"3.6\"         \"5\"           #> True P(DLT)      \"0.01\"      \"0.02\"      \"0.03\"      \"0.05\"      \"0.09\"      \"0.12\"      \"0.19\"        \"0.29\"        #> True category    \"underdose\" \"underdose\" \"underdose\" \"underdose\" \"underdose\" \"underdose\" \"target dose\" \"target dose\" #> MTD declared (n) \"0\"         \"0\"         \"0\"         \"0\"         \"0\"         \"0\"         \"1\"           \"0\"           #>                  6          #> Dose             \"6\"        #> True P(DLT)      \"0.43\"     #> True category    \"overdose\" #> MTD declared (n) \"0\"        #>  #> $`#pat. mono1.a` #>             0.1   0.2   0.4   0.8   1.6   2.4   3.6   5   6   #> Dose        \"0.1\" \"0.2\" \"0.4\" \"0.8\" \"1.6\" \"2.4\" \"3.6\" \"5\" \"6\" #> mean #pat   \"3\"   \"3\"   \"3\"   \"6\"   \"3\"   \"3\"   \"6\"   \"0\" \"0\" #> median #pat \"3\"   \"3\"   \"3\"   \"6\"   \"3\"   \"3\"   \"6\"   \"0\" \"0\" #> min #pat    \"3\"   \"3\"   \"3\"   \"6\"   \"3\"   \"3\"   \"6\"   \"0\" \"0\" #> max #pat    \"3\"   \"3\"   \"3\"   \"6\"   \"3\"   \"3\"   \"6\"   \"0\" \"0\" #>  #> $`#DLT mono1.a` #>             0.1   0.2   0.4   0.8   1.6   2.4   3.6   5   6   #> Dose        \"0.1\" \"0.2\" \"0.4\" \"0.8\" \"1.6\" \"2.4\" \"3.6\" \"5\" \"6\" #> mean #DLT   \"0\"   \"0\"   \"0\"   \"1\"   \"0\"   \"0\"   \"2\"   \"0\" \"0\" #> median #DLT \"0\"   \"0\"   \"0\"   \"1\"   \"0\"   \"0\"   \"2\"   \"0\" \"0\" #> min #DLT    \"0\"   \"0\"   \"0\"   \"1\"   \"0\"   \"0\"   \"2\"   \"0\" \"0\" #> max #DLT    \"0\"   \"0\"   \"0\"   \"1\"   \"0\"   \"0\"   \"2\"   \"0\" \"0\" #>  #> $`historical data` #>        Obs1 Obs2 Obs3 Obs4 Obs5 #> Dose 1    0    0    0    0    0 #> Dose 2    2    4    8   12   16 #> N Pat.    3    3    3    9   12 #> N DLT     0    0    0    1    2 #> Trial     7    7    7    7    7 #>  #> $prior #>               mean        SD #> mu_a1   -0.7081851 3.0000000 #> mu_b1    0.0000000 1.0000000 #> mu_a2   -0.7081851 3.0000000 #> mu_b2    0.0000000 1.0000000 #> mu_eta   0.0000000 1.1210000 #> tau_a1  -1.3862944 0.3536465 #> tau_b1  -2.0794415 0.3536465 #> tau_a2  -1.3862944 0.3536465 #> tau_b2  -2.0794415 0.3536465 #> tau_eta -2.0794415 0.3536465 #>  #> $specifications #>                                  Value       -      #> seed                             \"558535265\" \"-\"    #> dosing.intervals                 \"0.16\"      \"0.33\" #> esc.rule                         \"ewoc\"      \"-\"    #> esc.comp.max                     \"1\"         \"-\"    #> dose.ref1                        \"6\"         \"-\"    #> dose.ref2                        \"12\"        \"-\"    #> saturating                       \"FALSE\"     \"-\"    #> ewoc.threshold                   \"0.25\"      \"-\"    #> start.dose.mono1.a               \"0.1\"       \"-\"    #> esc.step.mono1.a                 \"2\"         \"-\"    #> esc.constrain.mono1.a            \"TRUE\"      \"-\"    #> max.n.mono1.a                    \"45\"        \"-\"    #> cohort.size.mono1.a              \"3\"         \"-\"    #> cohort.prob.mono1.a              \"1\"         \"-\"    #> mtd.decision.mono1.a$target.prob \"0.5\"       \"-\"    #> mtd.decision.mono1.a$pat.at.mtd  \"6\"         \"-\"    #> mtd.decision.mono1.a$min.pat     \"12\"        \"-\"    #> mtd.decision.mono1.a$min.dlt     \"1\"         \"-\"    #> mtd.decision.mono1.a$rule        \"2\"         \"-\"    #> mtd.enforce.mono1.a              \"FALSE\"     \"-\"    #> backfill.mono1.a                 \"FALSE\"     \"-\"    #> backfill.size.mono1.a            \"3\"         \"-\"    #> backfill.prob.mono1.a            \"1\"         \"-\"    #> backfill.start.mono1.a           \"0.1\"       \"-\"    #> start.dose.combi.a1              \"0.2\"       \"-\"    #> start.dose.combi.a2              \"8\"         \"-\"    #> esc.step.combi.a1                \"2\"         \"-\"    #> esc.step.combi.a2                \"1.5\"       \"-\"    #> esc.constrain.combi.a1           \"TRUE\"      \"-\"    #> esc.constrain.combi.a2           \"TRUE\"      \"-\"    #> max.n.combi.a                    \"36\"        \"-\"    #> cohort.size.combi.a              \"3\"         \"-\"    #> cohort.prob.combi.a              \"1\"         \"-\"    #> mtd.decision.combi.a$target.prob \"0.5\"       \"-\"    #> mtd.decision.combi.a$pat.at.mtd  \"6\"         \"-\"    #> mtd.decision.combi.a$min.pat     \"12\"        \"-\"    #> mtd.decision.combi.a$min.dlt     \"1\"         \"-\"    #> mtd.decision.combi.a$rule        \"2\"         \"-\"    #> mtd.enforce.combi.a              \"FALSE\"     \"-\"    #> backfill.combi.a                 \"FALSE\"     \"-\"    #> backfill.size.combi.a            \"3\"         \"-\"    #> backfill.prob.combi.a            \"1\"         \"-\"    #> backfill.start.combi.a1          \"0.1\"       \"-\"    #> backfill.start.combi.a2          \"8\"         \"-\"    #>  #> $`Stan options` #>                 Value #> chains            4.0 #> iter          13500.0 #> warmup         1000.0 #> adapt_delta       0.8 #> max_treedepth    15.0"},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/intro_jointBLRM.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Evaluate prior specifications of a joint BLRM for oncology dose finding","text":"","code":"sessionInfo() #> R version 4.1.2 (2021-11-01) #> Platform: x86_64-w64-mingw32/x64 (64-bit) #> Running under: Windows 10 x64 (build 19044) #>  #> Matrix products: default #>  #> locale: #> [1] LC_COLLATE=German_Germany.1252  LC_CTYPE=German_Germany.1252    LC_MONETARY=German_Germany.1252 #> [4] LC_NUMERIC=C                    LC_TIME=German_Germany.1252     #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] future.batchtools_0.12.0 parallelly_1.35.0        doRNG_1.8.2              rngtools_1.5.2           #> [5] doFuture_1.0.0           future_1.32.0            foreach_1.5.2            decider_0.0.0.9011       #>  #> loaded via a namespace (and not attached): #>  [1] httr_1.4.2           RcppParallel_5.1.5   StanHeaders_2.21.0-7 askpass_1.1          highr_0.9            #>  [6] stats4_4.1.2         base64url_1.4        yaml_2.2.2           progress_1.2.2       globals_0.16.1       #> [11] pillar_1.7.0         backports_1.4.1      glue_1.6.1           digest_0.6.29        checkmate_2.1.0      #> [16] colorspace_2.0-3     htmltools_0.5.2      pkgconfig_2.0.3      rstan_2.21.5         listenv_0.8.0        #> [21] purrr_0.3.4          scales_1.2.1         processx_3.8.1       brew_1.0-6           openxlsx_4.2.5.2     #> [26] tibble_3.1.6         openssl_1.4.6        generics_0.1.1       farver_2.1.0         ggplot2_3.3.6        #> [31] ellipsis_0.3.2       cachem_1.0.6         withr_2.5.0          cli_3.4.1            magrittr_2.0.2       #> [36] crayon_1.5.1         memoise_2.0.1        evaluate_0.14        ps_1.6.0             fs_1.5.2             #> [41] fansi_1.0.2          doParallel_1.0.17    pkgbuild_1.3.1       tools_4.1.2          loo_2.5.1            #> [46] data.table_1.14.2    prettyunits_1.1.1    hms_1.1.1            lifecycle_1.0.3      matrixStats_0.62.0   #> [51] stringr_1.4.0        munsell_0.5.0        zip_2.2.0            callr_3.7.3          pkgdown_2.0.7        #> [56] compiler_4.1.2       rlang_1.0.6          grid_4.1.2           iterators_1.0.14     rstudioapi_0.13      #> [61] rappdirs_0.3.3       labeling_0.4.2       rmarkdown_2.11       gtable_0.3.0         codetools_0.2-18     #> [66] flock_0.7            inline_0.3.19        R6_2.5.1             gridExtra_2.3        knitr_1.37           #> [71] dplyr_1.0.7          fastmap_1.1.0        future.apply_1.9.1   utf8_1.2.2           rprojroot_2.0.3      #> [76] desc_1.4.1           stringi_1.7.6        parallel_4.1.2       Rcpp_1.0.8.3         vctrs_0.4.2          #> [81] batchtools_0.9.17    tidyselect_1.1.1     xfun_0.29"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/parallelization_jointBLRM.html","id":"simple-parallelization","dir":"Articles","previous_headings":"","what":"Simple parallelization","title":"Parallelizing functions of the decider package","text":"First, following packages loaded doFuture, register simple parallel backend given number cores, set argument n.cores. purpose vignette, use single core due technical reasons, running code locally, one can easily change depending number cores available. figure many cores available, one can use e.g. Following initialization parallel backend, can simply run one four parallelized functions decider package. automatically leverage number cores registered. example, simple simulation accomplished : , 3 studies simulated illustration purposes. Please note, simulations, one can also initiate storing re-loading MCMC results speed simulations parallelizing moderate number cores (e.g., one using cluster). details, refer argument working.path function sim_jointBLRM().","code":"library(decider) library(doFuture) #specify number of cores -- here, only 1 for a sequential execution n.cores <- 1  #register backend for parallel execution and plan multisession doFuture::registerDoFuture() future::plan(future::multisession, workers=n.cores) parallel::detectCores() #> [1] 8 sim_result <- sim_jointBLRM(   active.mono1.a = TRUE,   active.combi.a = TRUE,    doses.mono1.a = c(2, 4, 8),   doses.combi.a = rbind(     c(2, 4, 8,  2, 4, 8),     c(1, 1, 1,  2, 2, 2)   ),   dose.ref1 = 8,   dose.ref2 = 2,   start.dose.mono1.a = 2,   start.dose.combi.a1 = 2,   start.dose.combi.a2 = 1,    tox.mono1.a = c(0.2, 0.3, 0.5),   tox.combi.a = c(0.3, 0.4, 0.6,  0.4, 0.5, 0.7),   max.n.mono1.a = 12,   max.n.combi.a = 24,   cohort.size = 3,   cohort.queue = c(1, 1, 1, rep(c(1, 3), times = 100)),   n.studies = 3 )  print(sim_result, quote = F) #> $`results combi.a` #>                              underdose target dose overdose max n reached before MTD all doses too toxic #> Number of trials             0         0           0        0                        3                   #> Percentage                   0         0           0        0                        100                 #> Percentage not all too toxic                                                                             #>  #> $`summary combi.a` #>                     Median      Mean      Min. Max. 2.5%     97.5% #> #Pat underdose   0.0000000 0.0000000 0.0000000    0 0.00 0.0000000 #> #Pat target dose 3.0000000 3.0000000 3.0000000    3 3.00 3.0000000 #> #Pat overdose    0.0000000 0.0000000 0.0000000    0 0.00 0.0000000 #> #Pat (all)       3.0000000 3.0000000 3.0000000    3 3.00 3.0000000 #> #DLT underdose   0.0000000 0.0000000 0.0000000    0 0.00 0.0000000 #> #DLT target dose 2.0000000 2.0000000 1.0000000    3 1.05 2.9500000 #> #DLT overdose    0.0000000 0.0000000 0.0000000    0 0.00 0.0000000 #> #DLT (all)       2.0000000 2.0000000 1.0000000    3 1.05 2.9500000 #> % overdose       0.0000000 0.0000000 0.0000000    0 0.00 0.0000000 #> % DLT            0.6666667 0.6666667 0.3333333    1 0.35 0.9833333 #>  #> $`MTDs combi.a` #>                  2+1         4+1      8+1      2+2      4+2      8+2      #> Dose             2+1         4+1      8+1      2+2      4+2      8+2      #> True P(DLT)      0.3         0.4      0.6      0.4      0.5      0.7      #> True category    target dose overdose overdose overdose overdose overdose #> MTD declared (n) 0           0        0        0        0        0        #>  #> $`#pat. combi.a` #>             2+1 4+1 8+1 2+2 4+2 8+2 #> Dose        2+1 4+1 8+1 2+2 4+2 8+2 #> mean #pat   3   0   0   0   0   0   #> median #pat 3   0   0   0   0   0   #> min #pat    3   0   0   0   0   0   #> max #pat    3   0   0   0   0   0   #>  #> $`#DLT combi.a` #>             2+1 4+1 8+1 2+2 4+2 8+2 #> Dose        2+1 4+1 8+1 2+2 4+2 8+2 #> mean #DLT   2   0   0   0   0   0   #> median #DLT 2   0   0   0   0   0   #> min #DLT    1   0   0   0   0   0   #> max #DLT    3   0   0   0   0   0   #>  #> $`results mono1.a` #>                              underdose target dose overdose max n reached before MTD all doses too toxic #> Number of trials                     0     1.00000        0                        0             2.00000 #> Percentage                           0    33.33333        0                        0            66.66667 #> Percentage not all too toxic         0   100.00000        0                        0                  NA #>  #> $`summary mono1.a` #>                     Median      Mean Min.       Max.      2.5%      97.5% #> #Pat underdose   0.0000000 0.0000000 0.00  0.0000000 0.0000000  0.0000000 #> #Pat target dose 9.0000000 8.0000000 3.00 12.0000000 3.3000000 11.8500000 #> #Pat overdose    0.0000000 0.0000000 0.00  0.0000000 0.0000000  0.0000000 #> #Pat (all)       9.0000000 8.0000000 3.00 12.0000000 3.3000000 11.8500000 #> #DLT underdose   0.0000000 0.0000000 0.00  0.0000000 0.0000000  0.0000000 #> #DLT target dose 3.0000000 2.3333333 1.00  3.0000000 1.1000000  3.0000000 #> #DLT overdose    0.0000000 0.0000000 0.00  0.0000000 0.0000000  0.0000000 #> #DLT (all)       3.0000000 2.3333333 1.00  3.0000000 1.1000000  3.0000000 #> % overdose       0.0000000 0.0000000 0.00  0.0000000 0.0000000  0.0000000 #> % DLT            0.3333333 0.3055556 0.25  0.3333333 0.2541667  0.3333333 #>  #> $`MTDs mono1.a` #>                  2           4           8        #> Dose             2           4           8        #> True P(DLT)      0.2         0.3         0.5      #> True category    target dose target dose overdose #> MTD declared (n) 1           0           0        #>  #> $`#pat. mono1.a` #>             2 4 8 #> Dose        2 4 8 #> mean #pat   5 3 0 #> median #pat 6 3 0 #> min #pat    3 0 0 #> max #pat    6 6 0 #>  #> $`#DLT mono1.a` #>             2                 4                8 #> Dose        2                 4                8 #> mean #DLT   0.666666666666667 1.66666666666667 0 #> median #DLT 1                 2                0 #> min #DLT    0                 0                0 #> max #DLT    1                 3                0 #>  #> $prior #>               mean       SD #> mu_a1   -0.7081851 2.000000 #> mu_b1    0.0000000 1.000000 #> mu_a2   -0.7081851 2.000000 #> mu_b2    0.0000000 1.000000 #> mu_eta   0.0000000 1.121000 #> tau_a1  -1.3862944 0.707293 #> tau_b1  -2.0794415 0.707293 #> tau_a2  -1.3862944 0.707293 #> tau_b2  -2.0794415 0.707293 #> tau_eta -2.0794415 0.707293 #>  #> $specifications #>                                  Value     -    #> seed                             830451341 -    #> dosing.intervals                 0.16      0.33 #> esc.rule                         ewoc      -    #> esc.comp.max                     1         -    #> dose.ref1                        8         -    #> dose.ref2                        2         -    #> saturating                       FALSE     -    #> ewoc.threshold                   0.25      -    #> start.dose.mono1.a               2         -    #> esc.step.mono1.a                 2         -    #> esc.constrain.mono1.a            FALSE     -    #> max.n.mono1.a                    12        -    #> cohort.size.mono1.a              3         -    #> cohort.prob.mono1.a              1         -    #> mtd.decision.mono1.a$target.prob 0.5       -    #> mtd.decision.mono1.a$pat.at.mtd  6         -    #> mtd.decision.mono1.a$min.pat     12        -    #> mtd.decision.mono1.a$min.dlt     1         -    #> mtd.decision.mono1.a$rule        2         -    #> mtd.enforce.mono1.a              FALSE     -    #> backfill.mono1.a                 FALSE     -    #> backfill.size.mono1.a            3         -    #> backfill.prob.mono1.a            1         -    #> backfill.start.mono1.a           2         -    #> start.dose.combi.a1              2         -    #> start.dose.combi.a2              1         -    #> esc.step.combi.a1                2         -    #> esc.step.combi.a2                2         -    #> esc.constrain.combi.a1           FALSE     -    #> esc.constrain.combi.a2           FALSE     -    #> max.n.combi.a                    24        -    #> cohort.size.combi.a              3         -    #> cohort.prob.combi.a              1         -    #> mtd.decision.combi.a$target.prob 0.5       -    #> mtd.decision.combi.a$pat.at.mtd  6         -    #> mtd.decision.combi.a$min.pat     12        -    #> mtd.decision.combi.a$min.dlt     1         -    #> mtd.decision.combi.a$rule        2         -    #> mtd.enforce.combi.a              FALSE     -    #> backfill.combi.a                 FALSE     -    #> backfill.size.combi.a            3         -    #> backfill.prob.combi.a            1         -    #> backfill.start.combi.a1          2         -    #> backfill.start.combi.a2          1         -    #>  #> $`Stan options` #>                 Value #> chains            4.0 #> iter          13500.0 #> warmup         1000.0 #> adapt_delta       0.8 #> max_treedepth    15.0"},{"path":"https://Boehringer-Ingelheim.github.io/decider/articles/parallelization_jointBLRM.html","id":"parallelization-on-a-cluster","dir":"Articles","previous_headings":"","what":"Parallelization on a cluster","title":"Parallelizing functions of the decider package","text":"functions decider package allow parallelization feature nested foreach loop two stages. , possible leverage capabilities multiple cluster nodes multiple cores. Usually, simulations joint BLRM trials multiple arms take relatively long run time (order hours) executed regular computer moderate amount cores, running simulations cluster may desirable achieve manageable runtimes. Please note function sim_jointBLRM parallelizes across trials, , simulating e.g. 1000 trials, multiple hundreds cores can used substantially improve run time. following, illustrated exemplary parallel backend common SLURM cluster registered. use future.batchtools package : Let us assume cluster available want request 10 nodes 32 cores per node (320 cores total). specify ressources like job time memory requested following arguments: , can allocate parallel backend given specifications: specification, e.g. sim_jointBLRM() called, trials need simulated first divided evenly across available nodes, trials simulated node distributed across CPUs node . example, simulate e.g. 6400 trials using 20 nodes 32 cores , node receive 320 trials, split across 32 cores, core need simulate 10 trials. setup, sim_jointBLRM() function can called way illustrated previously. Please note tradeoffs involed depending system, e.g. requesting large number cores may take time. last, please note function sim_jointBLRM() also supports use working.path argument allows enable saving reloading MCMC results. executed parallel backend, please note path must somewhere shared memory, CPUs access. Synchronization across CPUs carried using file locks, may introduce overhead. observed feature can potentially still provide significant benefits runtime (cluster standard computer), please aware highly experimental.","code":"library(future.batchtools) #number of processor nodes n_nodes <- 10 #number of cores per node n_cpus  <- 32 #job time in hours walltime_h <- 2 #memory requested in GB memory_gb  <- 4 slurm <- tweak(batchtools_slurm,                template  = system.file('templates/slurm-simple.tmpl', package = 'batchtools'),                workers   = n_nodes,                resources = list(                  walltime  = 60 * 60 * walltime_h,                  ncpus     = n_cpus,                  memory    = 1000 * memory_gb))  #register paralel backend on cluster registerDoFuture() plan(list(slurm, multisession))"},{"path":"https://Boehringer-Ingelheim.github.io/decider/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lukas Schroeter. Author, maintainer. Daniela Maier. Contributor. Boehringer Ingelheim Pharma GmbH & Co. KG. Copyright holder, funder.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Schroeter L (2023). decider: Decision making multiple-arm oncology dose escalation trials logistic regression. R package version 0.0.0.9011, https://Boehringer-Ingelheim.github.io/decider/.","code":"@Manual{,   title = {decider: Decision making in multiple-arm oncology dose escalation trials with logistic regression},   author = {Lukas Schroeter},   year = {2023},   note = {R package version 0.0.0.9011},   url = {https://Boehringer-Ingelheim.github.io/decider/}, }"},{"path":"https://Boehringer-Ingelheim.github.io/decider/index.html","id":"decider-r-package-decision-making-in-multiple-arm-oncology-dose-escalation-trials-with-logistic-regression","dir":"","previous_headings":"","what":"Decision making in multiple-arm oncology dose escalation trials with logistic regression","title":"Decision making in multiple-arm oncology dose escalation trials with logistic regression","text":"decider package created allow use Bayesian logistic regression models (BLRMs) decision making oncology dose escalation trials multiple arms. focuses use meta-analytic (“joint”) BLRM mono- combination therapy, uses hierarchical prior structure. package comes various functions allowing evaluate performance operating characteristics BLRM chosen prior given trial setting using trial simulations hypothetical data scenarios.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/index.html","id":"background-and-getting-started","dir":"","previous_headings":"","what":"Background and getting started","title":"Decision making in multiple-arm oncology dose escalation trials with logistic regression","text":"main model implemented package hierarchical (exchangeable) combination therapy BLRM following model described e.g. Neuenschwander et al. (2016) oncology dose finding combination therapy. posterior computations joint BLRM implemented using rstan package. detailed model description, refer documentation scenario_jointBLRM(). deciderpackage allows use basic hierarchical combination therapy model exchangeable prior structure together two variants general model: Inclusion binary covariate Use two different interaction terms following methodology described OncoBayes2, namely, linear interaction term saturating interaction term. core functions scenario_jointBLRM() sim_jointBLRM(), evaluation hypothetical data scenarios, respectively trial simulations. latter function allows simulations 6 parallel ongoing trial arms, arbitrarily many historical trials (mono /combination therapy), provides various options customization – instance, cohort size, order cohort enrolment different arms, dose escalation rules, things can adjusted. Additionally, simulations allow inclusion -called back-fill cohorts, lower doses backfilled escalation ongoing higher doses. Please refer vignette Evaluating prior specifications joint BLRM oncology dose finding introduction functions decider can used conduct BLRM simulations multiple arms evaluate hypothetical data scenarios.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Decision making in multiple-arm oncology dose escalation trials with logistic regression","text":"development version can installed follows:","code":"if(!requireNamespace(\"remotes\", quietly = TRUE)){   install.packages(\"remotes\") } remotes::install_github(\"https://github.com/Boehringer-Ingelheim/decider\")"},{"path":"https://Boehringer-Ingelheim.github.io/decider/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Decision making in multiple-arm oncology dose escalation trials with logistic regression","text":"package documentation hosted .","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/decider-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The 'decider' package: DECIsion making in oncology Dose Escalation trials with logistic Regression — decider-package","title":"The 'decider' package: DECIsion making in oncology Dose Escalation trials with logistic Regression — decider-package","text":"Performs Bayesian logistic regression binary dose-toxicity data monotherapy /(two-component) combination therapy dose-finding trials. underlying model referred Bayesian logistic regression model (BLRM) specified according Neuenschwander et al. (2008, 2014, 2016). Bayesian models implemented Stan modeling language (Stan Development Team (2020)) using rstan-package rstantools-package. Currently, -called joint BLRM included package. Different methods derivation dosing recommendations supported, among others escalation overdose control (EWOC) criterion goes back Babb et al. (1998). main functions sim_jointBLRM() scenario_jointBLRM(). Refer documentation entries detailed description underlying methods. methods implemented package mainly developed context oncology dose-finding trials, can also applied different therapeutic areas provided methodology estimating monotonically increasing dose-toxicity relationship based binary safety data applies. documentation argument names used package, typical terminology oncology trials used. , dose determined trials referred maximum tolerated dose (MTD), determined based binary safety data given -called dose-limiting toxicities (DLT). DLTs pre-specified set adverse events considered dose limiting. context, goal trial determine MTD true DLT rate pre-specified dosing interval. Note therapeutic areas often use slightly different notions instead.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/decider-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The 'decider' package: DECIsion making in oncology Dose Escalation trials with logistic Regression — decider-package","text":"Stan Development Team (2020). RStan: R interface Stan. R package version 2.21.2. https://mc-stan.org. Neuenschwander, B., Branson, M., & Gsponer, T. (2008). Critical aspects Bayesian approach phase cancer trials. Statistics medicine, 27(13), 2420-2439, doi:10.1002/sim.3230. Schmidli, H., Gsteiger, S., Roychoudhury, S., O'Hagan, ., Spiegelhalter, D., & Neuenschwander B. (2014). Robust meta-analytic-predictive priors clinical trials historical control information. Neuenschwander, B., Matano, ., Tang, Z., Roychoudhury, S., Wandel, S., & Bailey, S. (2014). Bayesian Industry Approach Phase Combination Trials Oncology. : Zhao. W & Yang, H. (editors). Statistical methods drug combination studies. Chapman Hall/CRC, 95-135, doi:10.1201/b17965. Neuenschwander, B., Roychoudhury, S., & Schmidli, H. (2016). use co-data clinical trials. Statistics Biopharmaceutical Research, 8(3), 345-354, doi:10.1080/19466315.2016.1174149. Babb, J., Rogatko, ., & Zacks, S. (1998). Cancer phase clinical trials: Efficient dose escalation overdose control. Statistics medicine 17(10), 1103-1120. Zhou, H.,  Yuan, Y., & Nie, L. (2018). Accuracy, safety, reliability novel phase designs. Clinical Cancer Research, 24(21), 5483-5484 <doi: 10.1158/1078-0432.ccr-18-0168>.","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_MAP.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute MAP priors for BLRMs — get_MAP","title":"Compute MAP priors for BLRMs — get_MAP","text":"Fit data one monotherapy combination therapy trials hierarchical BLRM extract estimates resulting meta-analytic predictive prior new monotherapy combination therapy trial. function get_MAP_mono() supports monotherapy data (one trials) input produce MAP prior two-parameter monotherapy BLRM. function get_MAP(), data one monotherapy /combination therapy trials can given, used derive MAP prior five-parameter combination therapy BLRM. Note also contains parameter implicit model monotherapy DLT rates, one can use get_MAP() principle also derive MAP priors monotherapy monotherapy combination therapy data.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_MAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute MAP priors for BLRMs — get_MAP","text":"","code":"get_MAP(   dose1,   dose2,   dose.ref1,   dose.ref2,   n.pat,   n.dlt,   trial,   prior.mu = list(mu_a1 =  c(logit(0.33), 2),                   mu_b1 =  c(0,           1),                   mu_a2 =  c(logit(0.33), 2),                   mu_b2 =  c(0,           1),                   mu_eta = c(0,           1.121)   ),   prior.tau = list(tau_a1 =  c(log(0.25),  log(2)/1.96),                    tau_b1 =  c(log(0.125), log(2)/1.96),                    tau_a2 =  c(log(0.25),  log(2)/1.96),                    tau_b2 =  c(log(0.125), log(2)/1.96),                    tau_eta = c(log(0.125), log(2)/1.96)   ),   saturating = FALSE,   return.samples = FALSE,   probs = c(0.025, 0.5, 0.975),   ... )  get_MAP_mono(    dose,    dose.ref,    n.pat,    n.dlt,    trial,    prior.mu.mono = list(mu_a =  c(logit(0.33), 2),                         mu_b =  c(0,          1)),    prior.tau.mono = list(tau_a =  c(log(0.25),  log(2)/1.96),                          tau_b =  c(log(0.125), log(2)/1.96)),    return.samples = FALSE,    probs = c(0.025, 0.5, 0.975),    ... )"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_MAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute MAP priors for BLRMs — get_MAP","text":"dose1 Numerical vector non-negative entries provide administered dose level compound 1 cohort. include monotherapy dose levels data given get_MAP(), one can use 0 NA indicate compound 1 administered cohort. Note cohorts dose1 dose2 either 0 NA removed data. dose2 Numerical vector non-negative entries provide administered dose level compound 2 cohort. include monotherapy dose levels data given get_MAP(), one can use 0 NA indicate compound 2 administered cohort. Note cohorts dose1 dose2 either 0 NA removed data. dose.ref1 Positive number, reference dose compound 1. dose.ref2 Positive number, reference dose compound 2. n.pat Numerical vector lists number patients cohort. n.dlt Numerical vector lists number DLTs cohort. trial Numerical character vector indicates trial cohort assigned . entries can either numericals strings, 1 \"1\" interpreted trial. Note given entries internally converted numbers 1 number different studies already given form. prior.mu Named list specifies distribution hypermeans parameters combination therapy BLRM. format, default, requirements documented function scenario_jointBLRM(). prior.tau Named list specifies distribution -trial heterogeneities parameters combination therapy BLRM. format, default, requirements documented function scenario_jointBLRM(). saturating Optional logical, defaults FALSE. TRUE, BLRM using saturating interaction term described OncoBayes2::blrm_formula_saturating(). Also refer Details section documentation scenario_jointBLRM(). return.samples Optional logical, defaults FALSE. TRUE, function return matrix samples MAP prior additionally prior summary. probs Optional numerical, defaults c(0.025, 0.5, 0.975). Indicates quantiles included posterior summaries. ... Optional additional arguments passed rstan::sampling(). include settings MCMC random seed. Refer rstan-package overview. Note function automatically use iter=10000 control argument containing adapt_delta=0.9 ensure relatively good fit arguments iter control rstan::sampling() provided manually .... dose Numerical vector lists dose levels monotherapy compound applied patient. length must equal number cohorts data. dose.ref Positive number, reference dose monotherapy compound. prior.mu.mono Optional named list specifies prior. Must entries mu_a mu_b, must vectors length 2, second entry positive number. entries need : ...$mu_a: Defaults c(logit(0.33), 2), provides mean SD normal distribution used hypermean \\(log(\\alpha)\\). ...$mu_b: Defaults c(0, 1), provides mean SD normal distribution used hypermean \\(log(\\beta)\\). prior.tau.mono Optional named list specifies prior. Must entries tau_a tau_b, must vectors length 2, second entry positive number. entries need : ...$tau_a: Defaults c(log(0.25), log(2)/1.96), provides mean SD (log-scale) log-normal distribution used -trial heterogeneity \\(log(\\alpha)\\). ...$tau_b: Defaults c(log(0.125), log(2)/1.96), provides mean SD (log-scale) log-normal distribution used -trial heterogeneity \\(log(\\beta)\\).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_MAP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute MAP priors for BLRMs — get_MAP","text":"table containing prior summaries MAP priors either parameters \\(log(\\alpha)\\) \\(log(\\beta)\\) (function get_MAP_mono()) parameters \\(log(\\alpha_1)\\), \\(log(\\beta_1)\\), \\(log(\\alpha_2)\\), \\(log(\\beta_2)\\), \\(\\eta\\) (function get_MAP()). return.samples TRUE, output instead list entries ...$summary ...$samples, first entry contains prior summary second entry table drawn samples parameter.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_MAP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute MAP priors for BLRMs — get_MAP","text":"model computing meta-analytic predictive prior specified according Neuenschwander et al. (2014, 2016). model description hierarchical BLRM used function obtain predictive distribution can found documentation scenario_jointBLRM(). underlying model monotherapy MAP priors two-parameter monotherapy variant general hierarchical model described documentation scenario_jointBLRM(). function get_MAP_mono() considers monotherapy, parameters \\(log(\\alpha)\\) \\(log(\\beta)\\) needed model DLT rate dose level. Besides , hierarchical model structure described scenario_jointBLRM() used.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_MAP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute MAP priors for BLRMs — get_MAP","text":"Stan Development Team (2020). RStan: R interface Stan. R package version 2.21.2. https://mc-stan.org. Neuenschwander, B., Branson, M., & Gsponer, T. (2008). Critical aspects Bayesian approach phase cancer trials. Statistics medicine, 27(13), 2420-2439, doi:10.1002/sim.3230. Schmidli, H., Gsteiger, S., Roychoudhury, S., O'Hagan, ., Spiegelhalter, D., & Neuenschwander B. (2014). Robust meta-analytic-predictive priors clinical trials historical control information. Neuenschwander, B., Matano, ., Tang, Z., Roychoudhury, S., Wandel, S., & Bailey, S. (2014). Bayesian Industry Approach Phase Combination Trials Oncology. : Zhao. W & Yang, H. (editors). Statistical methods drug combination studies. Chapman Hall/CRC, 95-135, doi:10.1201/b17965. Neuenschwander, B., Roychoudhury, S., & Schmidli, H. (2016). use co-data clinical trials. Statistics Biopharmaceutical Research, 8(3), 345-354, doi:10.1080/19466315.2016.1174149.","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_MAP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute MAP priors for BLRMs — get_MAP","text":"","code":"if (FALSE) { MAPprior_combi <- get_MAP(   dose1 = c(1, 2, 3, 4,   0, 0,   2, 2),   dose2 = c(0, 0, 0, 0,   5, 8,   5, 8),   n.pat = c(3, 3, 3, 6,   3, 9,   3, 6),   n.dlt = c(0, 0, 0, 1,   0, 0,   0, 0),   trial = c(1, 1, 1, 1,   2, 2,   3, 3),   dose.ref1 = 5,   dose.ref2 = 8,   return.samples = TRUE )  MAPprior_combi$summary MAPprior_combi$samples[, 1:8] } if (FALSE) { MAPprior <- get_MAP_mono(    dose =  c(1, 2, 3, 4),    n.pat = c(3, 3, 3, 6),    n.dlt = c(0, 0, 0, 1),    trial = c(1, 2, 1, 2),    dose.ref = 5,    return.samples = TRUE )  MAPprior$summary MAPprior$samples[, 1:8] }"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_pred_tox.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute predictive DLT rates for a new trial from historical data — get_pred_tox","title":"Compute predictive DLT rates for a new trial from historical data — get_pred_tox","text":"function get_pred_tox() can used derive predictive distributions DLT rates set dose levels considered new dose finding trial based historical data one dose-finding trials based joint BLRM. function supports monotherapy two-drug combination therapy essentially wrapper get_MAP() additionally computes samples predictive DLT rates drawn samples MAP prior. Note equivalent posterior distribution DLT rates trial recorded data yet joint BLRM including specified co-data trials. function get_pred_tox() can used monotherapy combination therapy. former, arguments dose2 dose.ref2 can left . function get_pred_tox_mono() uses slightly different syntax output structure specifically designed settings consisting purely monotherapy trials.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_pred_tox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute predictive DLT rates for a new trial from historical data — get_pred_tox","text":"","code":"get_pred_tox(  doses.of.interest,  dose1,  dose2,  dose.ref1,  dose.ref2,  n.pat,  n.dlt,  trial,  prior.mu = list(mu_a1 =  c(logit(0.33), 2),                  mu_b1 =  c(0,           1),                  mu_a2 =  c(logit(0.33), 2),                  mu_b2 =  c(0,           1),                  mu_eta = c(0,           1.121)                  ),  prior.tau = list(tau_a1 =  c(log(0.25),  log(2)/1.96),                   tau_b1 =  c(log(0.125), log(2)/1.96),                   tau_a2 =  c(log(0.25),  log(2)/1.96),                   tau_b2 =  c(log(0.125), log(2)/1.96),                   tau_eta = c(log(0.125), log(2)/1.96)                   ),  saturating = FALSE,  return.samples = FALSE,  probs = c(0.025, 0.5, 0.975),  dosing.intervals = c(0.16, 0.33),  ... )  get_pred_tox_mono(  doses.of.interest,  dose,  dose.ref,  n.pat,  n.dlt,  trial,  prior.mu.mono = list(mu_a =  c(logit(0.33), 2),                       mu_b =  c(0,          1)),  prior.tau.mono = list(tau_a =  c(log(0.25),  log(2)/1.96),                        tau_b =  c(log(0.125), log(2)/1.96)),  return.samples = FALSE,  probs = c(0.025, 0.5, 0.975),  dosing.intervals = c(0.16, 0.33),  ... )"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_pred_tox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute predictive DLT rates for a new trial from historical data — get_pred_tox","text":"doses..interest Numerical defines set dose levels meta-analytic predictive DLT rate computed. specification differs get_pred_tox() get_pred_tox_mono(). get_pred_tox(): Can either vector length 2 describes single dose combination (one doses can set 0 monotherapy doses), matrix 2 rows column defines dose combination. get_pred_tox_mono(): Can either vector giving set monotherapy dose levels, matrix exactly one row exactly one column. cases, number argument interpreted single dose. dose1 Numeric vector non-negative entries. Describes dose compound 1 administed patients cohort data, cohort assumed received dose1[] compound 1. Note dose1[] can set 0 indicate cohort received monotherapy compound 2. dose2 Numeric vector non-negative entries. Describes dose compound 2 administed patients cohort data, cohort assumed received dose2[] compound 2. Note dose2[] can set 0 indicate cohort received monotherapy compound 1. dose.ref1 Positive number, reference dose compound 1. dose.ref2 Positive number, reference dose compound 2. n.pat Numeric vector non-negative whole numbers entries. n.pat[] indicates number patients treated cohort . n.dlt Numeric vector non-negative whole numbers entries. n.dlt[] indicates number patients experienced DLT cohort . trial Numerical character vector indicates trial cohort assigned . entries can either numericals strings, 1 \"1\" interpreted trial. Note given entries internally converted numbers 1 number different studies already given form. prior.mu Named list specifies distribution hypermeans parameters combination therapy BLRM. format, default, requirements documented function scenario_jointBLRM(). prior.tau Named list specifies distribution -trial heterogeneities parameters combination therapy BLRM. format, default, requirements documented function scenario_jointBLRM(). saturating Optional logical, defaults FALSE. TRUE, BLRM using saturating interaction term described OncoBayes2::blrm_formula_saturating(). Also refer Details section documentation scenario_jointBLRM(). return.samples Optional logical, defaults FALSE. TRUE, function return matrix samples MAP prior additionally prior summary. probs Optional numerical, defaults c(0.025, 0.5,  0.975). Indicates quantiles included posterior summaries. dosing.intervals Optional numeric ascending positive entries 0 1. Defines limits dosing intervals evaluated, similarly scenario_jointBLRM(). default value c(0.16, 0.33). ... Optional additional arguments passed rstan::sampling(). include settings MCMC random seed. Refer rstan-package overview. Note function automatically use iter=10000 control argument containing adapt_delta=0.9 ensure relatively good fit arguments iter control rstan::sampling() provided manually .... dose Numeric vector non-negative entries defines monotherapy dose levels administered cohort. dose.ref Positive numerical, reference dose monotherapy. prior.mu.mono Optional named list specifies prior. Must entries mu_a mu_b, must vectors length 2, second entry positive number. entries need : ...$mu_a: Defaults c(logit(0.33), 2), provides mean SD normal distribution used hypermean \\(log(\\alpha)\\). ...$mu_b: Defaults c(0, 1), provides mean SD normal distribution used hypermean \\(log(\\beta)\\). prior.tau.mono Optional named list specifies prior. Must entries tau_a tau_b, must vectors length 2, second entry positive number. entries need : ...$tau_a: Defaults c(log(0.25), log(2)/1.96), provides mean SD (log-scale) log-normal distribution used -trial heterogeneity \\(log(\\alpha)\\). ...$tau_b: Defaults c(log(0.125), log(2)/1.96), provides mean SD (log-scale) log-normal distribution used -trial heterogeneity \\(log(\\beta)\\).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_pred_tox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute predictive DLT rates for a new trial from historical data — get_pred_tox","text":"Refer documentation scenario_jointBLRM() description underlying model used compute predictive distributions DLT rates. function get_pred_tox() can optionally return samples predictive distribution, can turn used perform single-dose analyses using e.g. binomial-beta-mixture model.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_pred_tox.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute predictive DLT rates for a new trial from historical data — get_pred_tox","text":"Stan Development Team (2020). RStan: R interface Stan. R package version 2.21.2. https://mc-stan.org. Neuenschwander, B., Branson, M., & Gsponer, T. (2008). Critical aspects Bayesian approach phase cancer trials. Statistics medicine, 27(13), 2420-2439, doi:10.1002/sim.3230. Schmidli, H., Gsteiger, S., Roychoudhury, S., O'Hagan, ., Spiegelhalter, D., & Neuenschwander B. (2014). Robust meta-analytic-predictive priors clinical trials historical control information. Neuenschwander, B., Matano, ., Tang, Z., Roychoudhury, S., Wandel, S., & Bailey, S. (2014). Bayesian Industry Approach Phase Combination Trials Oncology. : Zhao. W & Yang, H. (editors). Statistical methods drug combination studies. Chapman Hall/CRC, 95-135, doi:10.1201/b17965. Neuenschwander, B., Roychoudhury, S., & Schmidli, H. (2016). use co-data clinical trials. Statistics Biopharmaceutical Research, 8(3), 345-354, doi:10.1080/19466315.2016.1174149.","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/get_pred_tox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute predictive DLT rates for a new trial from historical data — get_pred_tox","text":"","code":"if (FALSE) { #derive the predictive distribution of the DLT rate of the dose 10+24 #from historical data of three previous trials pred <- get_pred_tox(  doses.of.interest = c(10, 24),  dose1 = c(2, 4, 8, 10, 14, 0,  0,  0,  4,  8,  10, 12),  dose2 = c(0, 0, 0, 0,  0,  12, 24, 36, 24, 24, 24, 24),  n.pat = c(3, 3, 3, 9,  6,  3,  12, 3,  3,  3,  9,  3),  n.dlt = c(0, 0, 0, 0,  2,  0,  1,  0,  0,  0,  1,  1),  trial = c(1, 1, 1, 1,  1,  2,  2,  2,  3,  3,  3,  3),  dose.ref1 = 14,  dose.ref2 = 24,  return.samples = TRUE )  #summary pred$summary  #first eight samples from predictive DLT rate pred$samples[, 1:8]  } if (FALSE) { #derive the predictive distribution of the DLT rates of the doses 8, 12, and #14 (monotherapy) from historical data of two previous trials pred_mono <- get_pred_tox_mono(  doses.of.interest = c(8, 12, 14),  dose  = c(2, 4, 8, 10, 14, 10, 14),  n.pat = c(3, 3, 3, 9,  6,  6,  12),  n.dlt = c(0, 0, 0, 0,  2,  0,  1),  trial = c(1, 1, 1, 1,  1,  2,  2),  dose.ref = 14,  return.samples = TRUE )  #summary pred_mono$summary  #first eight samples from predictive DLT rates pred_mono$samples[, 1:8]  }"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/logit.html","id":null,"dir":"Reference","previous_headings":"","what":"Logit and inverse logit function — logit","title":"Logit and inverse logit function — logit","text":"Logit inverse logit function work vectors, matrices, types arrays consist numerical entries.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/logit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logit and inverse logit function — logit","text":"","code":"logit(mu)  inv_logit(eta)"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/logit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logit and inverse logit function — logit","text":"mu array numerical entries 0 1. eta array arbitrary numerical entries.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/logit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logit and inverse logit function — logit","text":"Returns array either logits entries mu (function logit()) inverse logits entries eta (function inv_logit()).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/logit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Logit and inverse logit function — logit","text":"logit inverse logit function defined $$logit(x)=log(x/(1-x)),$$ $$inv\\_logit(y)=exp(y)/(1+exp(y)).$$ particular, one \\(logit(inv\\_logit(y))=y\\) \\(inv\\_logit(logit(x))=x\\). functions extracted stats::family object family binomial().","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/logit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logit and inverse logit function — logit","text":"","code":"y <- logit(0.1) inv_logit(y) #> [1] 0.1 logit(c(0.1, 0.2, 0.3, 0.4, 0.5)) #> [1] -2.1972246 -1.3862944 -0.8472979 -0.4054651  0.0000000 inv_logit(c(-2, -1, 0, 1, 2)) #> [1] 0.1192029 0.2689414 0.5000000 0.7310586 0.8807971"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_covariate_jointBLRM.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","title":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","text":"Evaluates data scenarios consisting observations one monotherapy two-drug combination therapy dose-finding trials including binary covariate computes posterior toxicities trial interest set doses interest. function supports one-sided two-sided covariates. can controlled separately thw two compounds. general introduction use scenario functions included package, see introduction vignette: vignette(\"intro_jointBLRM\", package = \"decider\"). Also refer documentation scenario_jointBLRM(). multiple scenarios need evaluated, consider using function scenario_list_covariate_jointBLRM() instead, parallelized wrapper processes list data scenarios within setting via scenario_covariate_jointBLRM(). description underlying model methods given section Details.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_covariate_jointBLRM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","text":"","code":"scenario_covariate_jointBLRM(    data=NULL,    historical.data=NULL,    doses.of.interest,    doses.of.interest.covars = NULL,    dose.ref1,    dose.ref2,    trials.of.interest,    types.of.interest=NULL,    trials.of.interest.covars=NULL,    esc.rule=c(\"ewoc\", \"loss\", \"dynamic.loss\"),    dosing.intervals = c(0.16, 0.33, 0.6),    ewoc.threshold = 0.25,    loss.weights = c(1, 0, 1, 2),    dynamic.weights = rbind(c(0.32, 0, 0.32, 0.36),                            c(0.29, 0, 0.31, 0.4),                            c(0.27, 0, 0.33, 0.4),                            c(0.2,  0, 0.3,  0.5)    ),    prior.mu = list(mu_a1 =  c(logit(0.33), 2),                    mu_b1 =  c(0,           1),                    mu_a2 =  c(logit(0.33), 2),                    mu_b2 =  c(0,           1),                    mu_eta = c(0,           1.121)    ),    prior.mu.covar = list(mu_g1 = c(0,  1),                          mu_g2 = c(0,  1)    ),    prior.tau = list(tau_a1 =  c(log(0.25),  log(2)/1.96),                     tau_b1 =  c(log(0.125), log(2)/1.96),                     tau_a2 =  c(log(0.25),  log(2)/1.96),                     tau_b2 =  c(log(0.125), log(2)/1.96),                     tau_eta = c(log(0.125), log(2)/1.96)    ),    prior.tau.covar = list(tau_g1 = c(log(0.125), log(2)/1.96),                           tau_g2 = c(log(0.125), log(2)/1.96)    ),    two_sided1 = TRUE,    two_sided2 = TRUE,    saturating = FALSE,    probs = c(0.025, 0.5, 0.975),    iter = 26000,    warmup = 1000,    refresh = 0,    adapt_delta = 0.8,    max_treedepth = 15,    chains = 4,    digits = 5,    seed=sample.int(.Machine$integer.max, 1),    path = NULL,    file.name = NULL,    output.dosetrafo = list(      \"d1c0\" = function(x) return(x),      \"d1c1\" = function(x) return(x),      \"d2c0\" = function(x) return(x),      \"d2c1\" = function(x) return(x)    ),    plot.decisions = FALSE,    plot.combi.heatmap = TRUE,    plot.int.probs.loss = FALSE,    plot.return = FALSE,    plot.file.format = \"pdf\",    plot.width,    plot.height,    plot.unit,    output.scen.config = FALSE )"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_covariate_jointBLRM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","text":"data List contains data scenario evaluated. Can NULL prior shall computed. data list following named entries, need vectors length (length number cohorts data): data$dose1 Numeric vector, entry must non-negative. Entry \\(\\) provide dose level compound 1 administered cohort \\(\\) data. Use 0 NA state compound 1 used treatment cohort. Note: cohort, either data$dose1 data$dose2 must positive. data$dose2 Numeric vector, entry must non-negative. Entry \\(\\) provide dose level compound 2 administered cohort \\(\\) data. Use 0 NA state compound 2 used treatment cohort. Note: cohort, either data$dose1 data$dose2 must positive. data$n.pat Numeric vector, entry must non-negative integer. Entry \\(\\) provide number patients cohort \\(\\) data. 0 interpreted cohort treated yet. data contains solely cohorts 0 patients, function sample prior. data$n.dlt Numeric vector, entry must non-negative integer. Entry \\(\\) provide number DLTs cohort \\(\\) data. particular, values need smaller equal patient number corresponding cohort. data$trial Numeric character vector. entries trial names, .e. indicators trial cohort belongs. can either numbers strings (converted numbers internally). Note: mixed vectors numbers strings converted strings, entries 1 \"1\" interpreted trial. data$covar Numeric vector 0-1 entries indicating value binary covariate cohorts included data. , entry \\(\\) 0, value binary covariate assumed 0 patients cohort \\(\\), similarly entry 1. historical.data Optional named list, must structure data. equivalent include observations data historical.data. Trial names across data historical data must consistent, sense observations entries data$trial, respectively historical.data$trial interpreted belong trial. doses..interest Numeric matrix two rows non-negative entries. column gives dose combination interest. See scenario_jointBLRM() details. doses..interest.covars Numeric vector, defaults NULL. Must either NULL length number columns doses..interest. Allows provide covariate value dose interest decides displayed one covariates. Entries 0 1 cause dose displayed covariate values outputs. argument set NULL, doses displayed covariates dose.ref1 Numeric, must positive. Reference dose compound 1. dose.ref2 Numeric, must positive. Reference dose compound 2. trials..interest Optional vector numerical character trial numbers/names, posterior computed. See scenario_jointBLRM() details. types..interest Optional character vector one entry entry trials..interest specifies trial type corresponding trial interest. Supported trial types \"mono1\", \"mono2\",  \"combi\", \"\". See scenario_jointBLRM() details. trials..interest.covars Optional numerical vector either length 1 length trials..interest. Indicates (applicable) value covariate interest one trials interest. Entries can either 0, 1, NA, 1 represents value 1 binary covariate, 0 indicates value 0, NA indicates values interest given trial. Can used set fixed covariate value trial interest, cause function compute, return, plot results using value trial interest. parameter trials..interest.covars given, function include results values covariate trial (equivalent setting trials..interest.covars = NA). trials..interest.covars length 1, function use specified option trials interest given trials..interest, otherwise assumed trials..interest.covars[] provides option trial specified trials..interest[]. esc.rule Optional character. Can either \"ewoc\", \"loss\", \"dynamic\" \"dynamic.loss\", latter two treated synonymously. See scenario_jointBLRM() details. dosing.intervals Optional numeric 1, 2, 3 ascending positive entries. Must three entries esc.rule set \"loss\", \"dynamic.loss\", \"dynamic\", otherwise (.e. esc.rule \"ewoc\") lengths 1, 2, 3 permitted. See scenario_jointBLRM() details. ewoc.threshold Optional numeric 0 1. Overdosing thresholds EWOC plots. Defaults 0.25. loss.weights Optional numerical vector four entries (can arbitrary numbers), default c(1,0,1,2). Specifies weights used loss escalation. See scenario_jointBLRM() details. dynamic.weights Optional numerical matrix four rows four columns, arbitrary numbers entries.  Specifies interval weights/penalties used dynamic loss escalation. See scenario_jointBLRM() details. prior.mu Optional list gives prior distribution hyper means \\(\\mu\\). See scenario_jointBLRM() details. prior.mu.covar Optional named list gives prior distribution hyper-means additional parameters included joint BLRM realize binary covariate. Also refer Details section notation used following. argumentprior.mu.covar must list named entries mu_g1 mu_g2. must length 2, provide mean SD hyper-means parameters corresponding covariate compound 1 2. precisely: prior.mu.covar$mu_g1 Numeric length two, defaults c(0, 1). Specifies mean SD hypermean \\(\\mu_6\\) parameter \\(\\gamma_1\\) BLRM. second entry must therefore positive. See Details section detail. prior.mu.covar$mu_g2 Numeric length two, defaults c(0, 1). Specifies mean SD hypermean \\(\\mu_7\\) parameter \\(\\gamma_2\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau Optional list gives prior distribution -trial heterogeneities (hyper SD) \\(\\tau\\). See scenario_jointBLRM() details. prior.tau.covar Optional named list gives prior distribution -trial heterogeneities additional parameters included joint BLRM realize binary covariate. Also refer Details section notation used following. argumentprior.tau.covar must list named entries tau_g1 tau_g2. must length 2, provide mean SD hyper-means parameters corresponding covariate compound 1 2. precisely: prior.tau.covar$tau_g1 Numeric length two, defaults c(0, 1). Specifies mean SD -trial heterogeneity \\(\\tau_{\\gamma_1}\\) parameter \\(\\gamma_1\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau.covar$tau_g2 Numeric length two, defaults c(log(0.125), log(2)/1.96). Specifies mean SD -trial heterogeneity \\(\\tau_{\\gamma_2}\\) parameter \\(\\gamma_2\\) BLRM. second entry must therefore positive. See Details section detail. two_sided1 Optional logical, defaults TRUE. Indicates whether covariate assumed two-sided effect DLT rate compound 1. FALSE, function assume one-sided effect covariate DLT rate compound 1. See section Details formal description. two_sided2 Optional logical. Optional logical, defaults TRUE. Indicates whether covariate assumed two-sided effect DLT rate compound 2. FALSE, function assume one-sided effect covariate DLT rate compound 2. See section Details formal description. saturating Optional logical activates use saturating interaction term (instead linear), defaults FALSE. See scenario_jointBLRM() details. probs Optional numeric arbitrary entries 0 1. Provides levels quantiles displayed output. Defaults c(0.025, 0.5, 0.975). iter Optional integer, number total MCMC iterations per chain. Defaults 26000. Note: Number warmup iterations counted towards iter, .e. iter many iterations, first warmup many samples saved. warmup Optional integer, number warmup iterations discarded total MCMC iterations per chain. Defaults 1000. See scenario_jointBLRM() details. refresh Optional integer. Given Stan's refresh argument rstan::sampling(), defaults 0. See scenario_jointBLRM() details. adapt_delta Optional numeric 0.6 1, default 0.8. Given Stan's rstan::sampling() method control argument Stan. See scenario_jointBLRM() details. max_treedepth Optional integer, defaults 15. See scenario_jointBLRM() details. chains Optional integer. Number Markov chains constructed Stan. Defaults 4. digits Optional integer, defaults 5. See scenario_jointBLRM() details. seed Optional positive integer specifies seed used simulation. See scenario_jointBLRM() details. path Optional character specified path save resulting output files. NULL (default), output written (still returned R). Otherwise, checked whether path specifies directory, , yes, output saved . file.name Optional name output file. NULL missing, output saved (also valid path given). Results returned R case. Note plots returned R unless additional argument plot.return specified. output.dosetrafo Optional list functions applied transform doses given model doses presented output. default, transformation identiy function, meaning doses displayed given model. argument  output.dosetrafo named list entries output.dosetrafo$\"d1c0\", output.dosetrafo$\"d1c1\", output.dosetrafo$\"d2c0\", output.dosetrafo$\"d1c2\", entry function accepts returns positive numeric. display outputs (including plots), function applied transform given doses, [...]$d1c0 used transform dose/compound 1 covariate 0 [...]$d1c1 used covariate 1. applies dose/compound 2. argument can used e.g. different dosing schedules transformed scale modelling BLRM. instance, covariate 0 indicates weekly schedule, covariate 1 bi-weekly schedule, one set BLRM operate total dose received 2 weeks. weekly schedule, one may want backtransform display weekly dose instead dose received two weeks, accomplished setting output.dosetrafo$\"d2c0\" = function(x) return(x/2) cause function display half dose used modelling outputs doses covariate 0. plot.decisions Optional logical, defaults FALSE. TRUE, plots escalation decisions according specified escalation rule created. See scenario_jointBLRM() details. plot.combi.heatmap Optional logical, defaults TRUE. value TRUE, combination therapy plots created heatmaps instead bar plots. affects escalation rules. plot.int.probs.loss Optional logical, defaults FALSE. effect esc.rule either \"loss\" \"dynamic.loss\". case, value TRUE, additional plots created display interval probabilities complement (always created) plots display resulting expected loss. plot.return Optional logical, defaults FALSE. set TRUE, functions return created plots R result list. See scenario_jointBLRM() details. plot.file.format Optional character, defaults \"pdf\". Can either \"pdf\", \"jpeg\" \"png\". See scenario_jointBLRM() details. plot.width Optional numerical value vector, can length 1 3 must positive entries. Provides width output plots measured unit given plot.unit. See scenario_jointBLRM() details. plot.height Optional numerical value vector, can length 1 3 must positive entries. Provides height output plots measured unit given plot.unit. See scenario_jointBLRM() details. plot.unit Optional character string, can \"\", \"cm\", \"mm\". See scenario_jointBLRM() details. output.scen.config Optional logical, defaults FALSE. See scenario_jointBLRM() details.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_covariate_jointBLRM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","text":"List. output list least one entry trial interest provides summary posterior toxicities. summary contain posterior DLT rates using covariate interest corresponding trial provided argument trials..interest.covars. latter specified set NA trial, returned list contain two entries trial, one value covariate. output.scen.config TRUE, additional entries give input data included. plot.return plot.decisions TRUE, additional entry created holds list output plots ggplot2::ggplot objects. precisely, following list entries always generated: $trial-[...]_covar-[0/1] , [...] denotes given trial name trials..interest, [0/1] value binary covariate used posterior. entry gives matrix lists summary statistics interval probabilities based posterior DLT rate doses interest trial. Additionally, loss escalation active, expected loss dose listed. additionally output.scen.config active, following additional entries: $data Input data used fit joint BLRM. Includes cohorts data historical.data merged data matrix. $prior Contains specified (hyper-)prior distribution used joint BLRM. $configuration Contains remaining configurations, e.g. seed escalation rule. $'Stan options' Contains arguments given Stan, e.g. number MCMC iterations chains. additional plot list generated, entry: $plots List contains output plots ggplot2::ggplot objects. one entry trial, namely $plots$trial-[...]_covar-[0/1] , [...] denotes trial name one trials interest, [0/1] value binary covariate used posterior. entry trial either single ggplot2::ggplot object list objects. number entries determined remaining specifications plots. E.g., loss escalation performed, can either just plot expected loss dose, additionally second plot usual interval probabilities. Similarly, trial interest type \"\", 3 plots, one trial type dose levels included (mono 1, mono 2, combination).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_covariate_jointBLRM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","text":"basic joint BLRM defined according (Neuenschwander et al., 2014 2016). Refer section Details documentation scenario_jointBLRM() details general model definition. following, describe function includes binary covariate basic joint BLRM. Recall parameter vector used joint BLRM without covariates trial \\(j\\), .e. $$\\theta_j = (log(\\alpha_{1j}), log(\\beta_{1j}), log(\\alpha_{2j}), log(\\beta_{2j}), \\eta_j).$$ model effect binary covariate \\(c\\\\{0,1\\}\\) DLT rate \\(\\pi_j(d_i)\\) dose \\(d_i\\) compound \\(\\) monotherapy trial \\(j\\), assume exist two additional parameters: \\(\\gamma_{1j}\\) \\(\\gamma_{2j}\\). , assume new parameters can take arbitrary values, .e. \\(-\\infty < \\gamma_{ij} < \\infty\\) later assume normal distribution prior. new parameters assumed shift intercept (\\(log(\\alpha_{ij})\\)) logistic model patients \\(c=1\\), .e. covariate assumed act intercept compared patients \\(c=0\\). function scenario_covariate_jointBLRM() implements two-sided one-sided action covariate. precisely: Two-sided: Two-sided effect covariate () interpreted sense patients c=1 larger, lower, identical probability experiencing DLT dose compared patients c=0. assumed know cases apply, covariate increase decrease DLT rate model. One-sided: One-sided effect covariate () interpreted sense patients c=1 assumed larger probability experiencing DLT compared patients c=0, .e., model DLT rate enforcing DLT rate patients \\(c=1\\) larger patients \\(c=0\\). obvious reasons, one-sided covariate action applied strong evidence patients \\(c=1\\) must larger DLT rate patients \\(c=0\\).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_covariate_jointBLRM.html","id":"one-sided-one-two-sided-model-for-covariates","dir":"Reference","previous_headings":"","what":"One-sided one two-sided model for covariates","title":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","text":"Formally, speaking, one-sided two-sided covariates implemented follows joint BLRM covariates. Writing \\(\\pi_j(d_i)\\) DLT rate dose \\(d_i\\) compound \\(\\) trial \\(j\\), BLRM two-sided covariates assumes: $$ logit(\\pi_j(d_i)) = log(\\alpha_i) + \\beta \\cdot  log\\left(\\frac{d_i}{d^*_i}\\right) + c\\cdot \\gamma_{ij}. $$ words, DLT rate patients \\(c=0\\) assumed follow usual logistic model, patients \\(c=1\\) intercept shifted \\(\\gamma_{ij}\\). particular, intercept logistic model become larger smaller, depending value \\(\\gamma_{ij}\\). one-sided model assumes instead $$ logit(\\pi_j(d_i)) = log(\\alpha_i) + \\beta \\cdot  log\\left(\\frac{d_i}{d^*_i}\\right) + c\\cdot exp(\\gamma_{ij}). $$ , shift intercept assumed log-normally distributed variable, , specifically, shift \\(exp(\\gamma_{ij})\\) normally distributed \\(\\gamma_{ij}\\). particular, logit DLT rate, therefore DLT rate , guaranteed increase \\(c=1\\) compared \\(c=0\\).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_covariate_jointBLRM.html","id":"prior-specification-for-joint-blrm-with-binary-covariate","dir":"Reference","previous_headings":"","what":"Prior specification for joint BLRM with binary covariate","title":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","text":"Note can assume \\(\\gamma_{ij}\\) normally distributed one-sided two-sided models. allows include hierarchical random effects model joint BLRM fashion model parameters. specifically, consider trial \\(j\\) seven-dimensional parameter vector $$\\theta_j = \\theta_j = (log(\\alpha_{1j}), log(\\beta_{1j}), log(\\alpha_{2j}), log(\\beta_{2j}), \\eta_j, \\gamma_{1j}, \\gamma_{2j}).$$ random effects distribution, can proceed analogously case joint BLRM without covariates. , general hierarchical prior assume $$\\theta_j|\\mu,\\Sigma \\sim Normal_7(\\mu, \\Sigma)$$ shared hyper mean vector \\(\\mu\\) shared hyper covariance matrix \\(\\Sigma\\), entries $$\\mu=(\\mu_1, \\mu_2, \\mu_3, \\mu_4, \\mu_5, \\mu_6, \\mu_7)$$ $$\\Sigma = (\\Sigma_{kl})$$ \\(k=1,...,7\\), \\(l=1,...,7\\). entries \\(\\Sigma_{kl}\\) defined $$\\Sigma_{kk}=\\tau_k\\cdot\\tau_k$$ diagonal, $$\\Sigma_{kl}=\\rho_{kl}\\cdot\\tau_k\\cdot\\tau_l$$ \\(k\\) equal \\(l\\). , \\(\\rho_{kl}\\) correlation coefficients parameters \\(k\\) \\(l\\), \\(\\tau_k\\) standard deviations respective parameters. , assume parameters uncorrelated, except intercept log-slope model compound. , \\(\\rho_{kl}=0\\) \\(kl\\), except \\(\\rho_{12}\\) \\(\\rho_{34}\\). latter two assumed uniformly distributed \\([-1, 1]\\). model completed way joint BLRM without covariate, assuming $$\\mu_k \\sim Normal(m_{\\mu_k}, s_{\\mu_k}^2)$$ hyper-prior \\(\\mu_k\\) respectively $$\\tau_k \\sim logNormal(m_{\\tau_k}, s_{\\tau_k}^2)$$ \\(\\tau_k\\). Note model allows use prior distributions joint BLRM without covariate parameters \\(\\mu_k\\) \\(\\tau_k\\), except newly added \\(\\mu_6\\), \\(\\mu_7\\), \\(\\tau_6\\), \\(\\tau_7\\), correspond hyper-mean -trial heterogeneity parameters \\(\\gamma_{ij}\\). , use parameter name subscript \\(\\mu_k\\) \\(\\tau_k\\) indicate corresponding parameter. function scenario_covariate_jointBLRM() sim_covariate_jointBLRM(), priors \\(\\mu_6\\), \\(\\mu_7\\), \\(\\tau_6\\), \\(\\tau_7\\) controlled arguments prior.mu.covar prior.tau.covar, priors remaining \\(\\mu_k\\) \\(\\tau_k\\) specified arguments prior.mu prior.tau, use format names joint BLRM functions without covariate. entries prior.mu.covar correspond hyper-means \\(\\gamma_{ij}\\) specified following table. Similarly, entries prior.tau.covar follow conventions stated . Note prior.mu.covar can therefore used control size assumed difference across patients \\(c=0\\) \\(c=1\\). Assuming two-sided covariate, setting e.g. prior.mu.covar$mu_g1[1]=0 mean, one essentially states known whether covariate increases DLT rate, prior.mu.covar$mu_g1[1]>0 assumes \\(c=1\\) likely increase DLT rate. , increasing SD setting higher value prior.mu.covar$mu_g1[2], one essentially assumes larger uncertainty respect potential influence covariate, allowing greater differences across trials. Setting prior.mu.covar$mu_g1[2] value similar prior.mu$mu_a1[2] allow influence covariate potentially dominates influence (shared) intercept \\(log(\\alpha_{ij})\\), thereby reducing degree information sharing across cohorts \\(c=1\\) \\(c=0\\) substantially. Hence, using default value prior.mu$mu_a1[2]=2, one usually want choose prior.mu.covar$mu_g1[2] larger 1 1.5. one expects even larger uncertainty across \\(c=1\\) \\(c=0\\), may advantageous use different model includes uncertainty explicitly (e.g. exchangeale-non-exchangeable-type random effects models discussed e.g. (Schmidli et al., 2015), (Neuenschwander et al., 2016)). default values prior.mu.covar relatively conservative setting assume little concrete knowledge covariate influences DLT rates, often reasonable expectation early trials. default values therefore applicable wide range settings, can adjusted optimized situations concrete information influence covariate.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_covariate_jointBLRM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","text":"Stan Development Team (2020). RStan: R interface Stan. R package version 2.21.2. https://mc-stan.org Neuenschwander, B., Branson, M., & Gsponer, T. (2008). Critical aspects Bayesian approach phase cancer trials. Statistics medicine, 27(13), 2420-2439, doi:10.1002/sim.3230. Neuenschwander, B., Matano, ., Tang, Z., Roychoudhury, S., Wandel, S., & Bailey, S. (2014). Bayesian Industry Approach Phase Combination Trials Oncology. : Zhao. W & Yang, H. (editors). Statistical methods drug combination studies. Chapman Hall/CRC, 95-135, doi:10.1201/b17965. Neuenschwander, B., Roychoudhury, S., & Schmidli, H. (2016). use co-data clinical trials. Statistics Biopharmaceutical Research, 8(3), 345-354, doi:10.1080/19466315.2016.1174149. Schmidli, H., Gsteiger, S., Roychoudhury, S., O'Hagan, ., Spiegelhalter, D., Neuenschwander, B. (2014). Robust Meta-Analytic-Predictive Priors Clinical Trials Historical Control Information. Biometrics, 70(4), 1023-1032 <doi: 10.1111/biom.12242>. Babb, J., Rogatko, ., & Zacks, S. (1998). Cancer phase clinical trials: Efficient dose escalation overdose control. Statistics medicine 17(10), 1103-1120. Zhou, H.,  Yuan, Y., & Nie, L. (2018). Accuracy, safety, reliability novel phase designs. Clinical Cancer Research, 24(21), 5483-5484 <doi: 10.1158/1078-0432.ccr-18-0168>.","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_covariate_jointBLRM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate data from oncology dose finding using a joint BLRM with covariate — scenario_covariate_jointBLRM","text":"","code":"if (FALSE) { result <- scenario_covariate_jointBLRM(                    data=list(dose1 = c(1, 2, 4, 6, 8, 0,  0,  0,  1,  2),                              dose2 = c(0, 0, 0, 0, 0, 10, 20, 30, 10, 10),                              n.pat = c(3, 3, 3, 3, 3, 3,  6,  9,  3,  3),                              n.dlt = c(0, 0, 0, 0, 1, 0,  0,  1,  0,  0),                              trial = c(1, 1, 1, 1, 1, 2,  2,  3,  3,  3),                              covar = c(0, 0, 0, 0, 0, 1,  1,  1,  1,  1)                              ),                    trials.of.interest =        c(1,       3),                    types.of.interest =         c(\"mono1\", \"combi\"),                    trials.of.interest.covars = c(0,       1),                    doses.of.interest = rbind(                      c(1, 2, 4, 6, 8, 12,  rep(c(1, 2, 4, 6, 8, 12),                                                times=3)),                      c(0, 0, 0, 0, 0, 0,   rep(c(10, 20, 30),                                                each = 6 ))),                    dose.ref1 = 12,                    dose.ref2 = 30,                    esc.rule = \"dynamic.loss\",                    prior.mu = list(mu_a1 =  c(logit(0.33), 2),                                    mu_b1 =  c(0,          1),                                    mu_a2 =  c(logit(0.33), 2),                                    mu_b2 =  c(0,          1),                                    mu_eta = c(0,          1.121)),                    prior.tau = list(tau_a1 =  c(log(0.25),  log(2)/1.96),                                     tau_b1 =  c(log(0.125), log(2)/1.96),                                     tau_a2 =  c(log(0.25),  log(2)/1.96),                                     tau_b2 =  c(log(0.125), log(2)/1.96),                                     tau_eta = c(log(0.125), log(2)/1.96)),                    path = getwd(),                    file.name = NULL,                    iter=10000,                    chains=4                    ) }"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"Evaluates data scenarios consisting observations one monotherapy two-drug combination therapy dose-finding trials computes posterior toxicities trial interest set doses interest. introduction use function, see introduction vignette: vignette(\"intro_jointBLRM\", package = \"decider\"). multiple scenarios need evaluated, consider using function scenario_list_jointBLRM() instead, parallelized wrapper processes list data scenarios within setting via scenario_jointBLRM(). description underlying model methods given section Details.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"","code":"scenario_jointBLRM(    data=NULL,    historical.data=NULL,    doses.of.interest,    dose.ref1,    dose.ref2,    trials.of.interest,    types.of.interest=NULL,    esc.rule=c(\"ewoc\", \"loss\", \"dynamic.loss\"),    dosing.intervals = c(0.16, 0.33, 0.6),    ewoc.threshold = 0.25,    loss.weights = c(1, 0, 1, 2),    dynamic.weights = rbind(c(0.32, 0, 0.32, 0.36),                            c(0.29, 0, 0.31, 0.4),                            c(0.27, 0, 0.33, 0.4),                            c(0.2,  0, 0.3,  0.5)    ),    prior.mu = list(mu_a1 =  c(logit(0.33), 2),                    mu_b1 =  c(0,           1),                    mu_a2 =  c(logit(0.33), 2),                    mu_b2 =  c(0,           1),                    mu_eta = c(0,           1.121)    ),    prior.tau = list(tau_a1 =  c(log(0.25),  log(2)/1.96),                     tau_b1 =  c(log(0.125), log(2)/1.96),                     tau_a2 =  c(log(0.25),  log(2)/1.96),                     tau_b2 =  c(log(0.125), log(2)/1.96),                     tau_eta = c(log(0.125), log(2)/1.96)    ),    saturating = FALSE,    probs = c(0.025, 0.5, 0.975),    iter = 26000,    warmup = 1000,    refresh = 0,    adapt_delta = 0.8,    max_treedepth = 15,    chains = 4,    digits = 5,    seed=sample.int(.Machine$integer.max, 1),    path = NULL,    file.name = NULL,    plot.decisions = FALSE,    plot.combi.heatmap = TRUE,    plot.int.probs.loss = FALSE,    plot.return = FALSE,    plot.file.format = \"pdf\",    plot.width,    plot.height,    plot.unit,    output.scen.config = FALSE )"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"data List contains data scenario evaluated. Can NULL prior shall computed. data list following named entries, need vectors length (length number cohorts data): data$dose1 Numeric vector, entry must non-negative. Entry \\(\\) provide dose level compound 1 administered cohort \\(\\) data. Use 0 NA state compound 1 used treatment cohort. Note: cohort, either data$dose1 data$dose2 must positive. data$dose2 Numeric vector, entry must non-negative. Entry \\(\\) provide dose level compound 2 administered cohort \\(\\) data. Use 0 NA state compound 2 used treatment cohort. Note: cohort, either data$dose1 data$dose2 must positive. data$n.pat Numeric vector, entry must non-negative integer. Entry \\(\\) provide number patients cohort \\(\\) data. 0 interpreted cohort treated yet. data contains solely cohorts 0 patients, function sample prior. data$n.dlt Numeric vector, entry must non-negative integer. Entry \\(\\) provide number DLTs cohort \\(\\) data. particular, values need smaller equal patient number corresponding cohort. data$trial Numeric character vector. entries trial names, .e. indicators trial cohort belongs. can either numbers strings (converted numbers internally). Note: mixed vectors numbers strings converted strings, entries 1 \"1\" interpreted trial. historical.data Optional named list, must structure data. equivalent include observations data historical.data, latter included solely convenience. Trial names across data historical data must consistent, sense observations entries data$trial, respectively historical.data$trial interpreted belong trial. Note argument included convenience, allows perform multiple inferences using set historical data changing new data, without include non-changing (historical) observations data argument. doses..interest Numeric matrix two rows non-negative entries. column gives dose combination interest, first row provides dose level compound 1, second row compound 2. NA entries interpreted \"dose administered\", .e. internally converted 0. Setting doses zero one column valid dose combination throw error. dose.ref1 Numeric, must positive. Reference dose compound 1. dose.ref2 Numeric, must positive. Reference dose compound 2. trials..interest Optional vector numerical character trial numbers/names, posterior computed. missing, trials included data argument used instead, , trials data historical.data, priors doses interest computed. Trial names consistent numbers given data argument. trial names included observations data argument, predictive DLT probabilities (based MAP approach) computed instead trials (.e., posterior trials depend data observed trials). types..interest Optional character vector one entry entry trials..interest specifies trial type corresponding trial interest. Supported trial types \"mono1\", \"mono2\",  \"combi\", \"\". types..interest provided, trial types inferred data given trial. type neither specified user uniquely inferable data (e.g. trials included data yet, trials including observations multiple types), trial type implicitly set \"\". available trial types specify dose levels doses..interest included summary corresponding trial interest. specifically, type trial interest ... ...\"mono1\": doses interest second compound 0 included summary (activated) plots. ...\"mono2\": doses interest fist compound 0 included summary (activated) plots. ...\"combi\": doses interest none compound 0 included summary (activated) plots. ...\"\": doses interest included summary. plots activated, plot generated trial type detected within doses interest. type \"\" escalation rule \"dynamic.loss\", dynamic Bayes risk (expected loss) computed based reference dose trial type corresponding type trial interest. , e.g. mono 1 combination doses included doses interest type \"\", dynamic Bayes risk select dose whether needs use mono reference doses reference dose combination. esc.rule Optional character. Can either \"ewoc\", \"loss\", \"dynamic\" \"dynamic.loss\", latter two treated synonymously. Note: \"loss\" \"dynamic.loss\" chosen, parameter dosing.intervals needs contain three entries, otherwise can either two three entries. esc.rule \"ewoc\", first two entries dosing.intervals used. See section Details description available methods. dosing.intervals Optional numeric 1, 2, 3 ascending positive entries. Must three entries esc.rule set \"loss\", \"dynamic.loss\", \"dynamic\", otherwise (.e. esc.rule \"ewoc\") lengths 1, 2, 3 permitted. dosing interval one entry (requires esc.rule \"ewoc\"), entry interpreted boundary DLT rates considered target dosing overdosing, .e., underdosing interval considered case. Otherwise (including default), entries 1 2 interpreted lower upper boundary target dosing interval. third entry ignored esc.rule \"ewoc\", values esc.rule required boundary dosing intervals containing excessive unacceptable DLT rates. argument dosing.intervals defaults c(0.16, 0.33, 0.6), corresponds using \\([0.16, 0.33)\\) target interval, \\([0.33,0.6)\\) excessive toxicity interval loss escalation. dosing.intervals one entry, say x, computation equivalent setting argument c(0, x), output tables plots formatted slightly differently reflect underdosing interval considered case. ewoc.threshold Optional numeric 0 1. Overdosing thresholds EWOC plots. Defaults 0.25. loss.weights Optional numerical vector four entries (can arbitrary numbers), default c(1,0,1,2). Specifies interval weights/penalties used static loss escalation. needed esc.rule \"loss\", parameter ignored otherwise. precisely, loss.weights[1] weight underdosing interval, loss.weights[2] weight  target dosing interval, loss.weights[3] weight excessively toxic dosing interval, loss.weights[4] weight unacceptably toxic dosing interval. See Details section explanations regarding methodology. dynamic.weights Optional numerical matrix four rows four columns, arbitrary numbers entries.  Specifies interval weights/penalties used dynamic loss escalation. needed esc.rule \"dynamic\" \"dynamic.loss\", parameter ignored otherwise. row dynamic.weights specifies one static loss weight vectors interpolated dynamic loss escalation. See Details section explanations regarding methodology. precisely, dynamic.weights[1, ] static weight vector weighted reference probability underdosing, dynamic.weights[2, ] static weight vector weighted reference probability target dosing, dynamic.weights[3, ] static weight vector weighted reference probability excessively toxic dosing, dynamic.weights[4, ] static weight vector weighted reference probability unacceptably toxic dosing. default value dynamic.weights matrix following four rows (order): c(0.32, 0, 0.32, 0.36), c(0.29, 0, 0.31, 0.40), c(0.27, 0, 0.33, 0.40), c(0.20, 0, 0.30, 0.50). prior.mu Optional list gives prior distribution hyper means \\(\\mu\\). list must named entries, need numeric vectors length 2: prior.mu$mu_a1 Numeric length two, defaults c(logit(0.33), 2). Specifies mean SD hypermean \\(\\mu_{\\alpha_1}\\) parameter \\(log(\\alpha_1)\\) BLRM. second entry must therefore positive. See Details section detail. prior.mu$mu_b1 Numeric length two, defaults c(0, 1). Specifies mean SD hypermean \\(\\mu_{\\beta_1}\\) parameter \\(log(\\beta_1)\\) BLRM. second entry must therefore positive. See Details section detail. prior.mu$mu_a2 Numeric length two, defaults c(logit(0.33), 2). Specifies mean SD hypermean \\(\\mu_{\\alpha_2}\\) parameter \\(log(\\alpha_2)\\) BLRM. second entry must therefore positive. See Details section detail. prior.mu$mu_b2 Numeric length two, defaults c(0, 1). Specifies mean SD hypermean \\(\\mu_{\\beta_2}\\) parameter \\(log(\\beta_2)\\) BLRM. second entry must therefore positive. See Details section detail. prior.mu$mu_eta Numeric length two, defaults c(0, 1.121). Specifies mean SD hypermean \\(\\mu_{\\eta}\\) parameter \\(\\eta\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau Optional list gives prior distribution -trial heterogeneities (hyper SD) \\(\\tau\\). list must named entries, need numeric vectors length 2: prior.tau$tau_a1 Numeric length two, defaults c(log(0.25), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_{\\alpha_1}\\) parameter \\(log(\\alpha_1)\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau$tau_b1 Numeric length two, defaults c(log(0.125), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_{\\beta_1}\\) parameter \\(log(\\beta_1)\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau$tau_a2 Numeric length two, defaults c(log(0.25), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_{\\alpha_2}\\) parameter \\(log(\\alpha_2)\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau$tau_b2 Numeric length two, defaults c(log(0.125), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_{\\beta_2}\\) parameter \\(log(\\beta_2)\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau$tau_eta Numeric length two, defaults c(log(0.125), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_{\\eta}\\) parameter \\(\\eta\\) BLRM. second entry must therefore positive. See Details section detail. saturating Optional logical, defaults FALSE. TRUE, BLRM using saturating interaction term described OncoBayes2::blrm_formula_saturating(). Also refer Details section . probs Optional numeric arbitrary entries 0 1. Provides levels quantiles displayed output. Defaults c(0.025, 0.5, 0.975). iter Optional integer, number total MCMC iterations per chain. Defaults 26000. Note: Number warmup iterations counted towards iter, .e. iter many iterations, first warmup many samples saved. warmup Optional integer, number warmup iterations discarded total MCMC iterations per chain. Defaults 1000. Note: Number warmup iterations counted towards iter, .e. iter many iterations, first warmup many samples saved. Refer rstan::sampling() rstan-package package details. refresh Optional integer. Given Stan's refresh argument rstan::sampling(), defaults 0. positive value indicates updates sampling progress printed every refresh many iterations. Set 0 avoid output Stan. Refer rstan::sampling() rstan-package package details. adapt_delta Optional numeric 0.6 1, default 0.8. Given Stan's rstan::sampling() method control argument Stan. Translates target Metropolis acceptance probability Hamiltonian Monte Carlo, respectively NUTS. Can used influence stepsize Stan uses leapfrog steps NUTS algorithm. See rstan::sampling(), rstan-package details. Note: One can increase value parameter order reduce number Stan warnings \"divergent transition\". Larger values 0.95 slow sampling. function permit set adapt_delta values 0.6 (rstan-package default). max_treedepth Optional integer, defaults 15. lower 10. parameter NUTS algorithm. Roughly speaking, NUTS constructs search tree generating new proposal, stopping criterion (NUTS criterion) satisfied , alternatively, maximum depth search tree reached (avoid endless looping). argument max_treedepth allows control latter. maximum treedepth also automatically constrain maximum number leapfrog steps, therefore 10. See also rstan::sampling() details max_treedepth. Note: maximum treedepth usually reached sampling, otherwise Stan print warning. case, recommended increase value. chains Optional integer. Number Markov chains constructed Stan. Defaults 4. digits Optional positive integer specified number digits used outputs. Defaults 5. seed Optional positive integer specifies seed used simulation. default sample.int(.Machine$integer.max, 1). Note reproducibility can obtained function executed exactly computing architecture, using identical software versions (e.g. compiler, Stan, R), input specifications. due internal use rstan-package MCMC sampling, reproducible restrictions (refer Stan reference manual rstan-package's homepage detail). path Optional character specified path save resulting output files. NULL (default), output written (still returned R). Otherwise, checked whether path specifies directory, , yes, output saved . file.name Optional name output file. NULL missing, output saved (also valid path given). Results returned R case. Note plots returned R unless additional argument plot.return specified. plot.decisions Optional logical, defaults FALSE. TRUE, plots escalation decisions according specified escalation rule created. plot.decisions TRUE, recommended supply writable path valid file.name, plots default saved returned R. Plots returned R additional argument plot.return specified. particular, plot.decisions TRUE plot.return FALSE, plots accessible unless valid file.name given enable saving plots. Depending value esc.rule, following plots created: esc.rule==\"ewoc\", diagram posterior probabilities DLT rate lies underdosing, target dosing overdosing intervals created, indicates boundary given ewoc.threshold red color coding (, therefore, implicitly decision EWOC-based dose escalation rules). trials types \"mono1\" \"mono2\" (cf. argument types..interest), bar plot created, trials type \"combi\", either heatmap overdosing probabilities can created (value plot.combi.heatmap TRUE) alternatively bar plot fashion monotherapy trials. esc.rule==\"loss\", diagram expected loss (Bayes risk) based weight choice loss.weights created. , argument plot.int.probs.loss can used additionally create plots underdosing, target dosing overdosing intervals. trials types \"mono1\" \"mono2\" (cf. argument types..interest), bar plot created, trials type \"combi\", either heatmap expected loss can created (plot.combi.heatmap==TRUE) alternatively bar plot fashion monotherapy trials. esc.rule==\"dynamic.loss\", diagram expected dynamic loss (dynamic Bayes risk) based weight choice dynamic.weights created. , argument plot.int.probs.loss can used additionally create plots underdosing, target dosing overdosing intervals. trials types \"mono1\" \"mono2\" (cf. argument types..interest), bar plot created, trials type \"combi\", either heatmap expected dynamic loss can created (plot.combi.heatmap==TRUE) alternatively bar plot fashion monotherapy trials. plot.combi.heatmap Optional logical, defaults TRUE. value TRUE, combination therapy plots created heatmaps instead bar plots. affects escalation rules. plot.int.probs.loss Optional logical, defaults FALSE. effect esc.rule either \"loss\" \"dynamic.loss\". case, value TRUE, additional plots created display interval probabilities complement (always created) plots display resulting expected loss. plot.return Optional logical, defaults FALSE. set TRUE, functions return created plots R result list. case, result list additional entry, ...$plots, contains posterior plots named list. returned plots given list ggplot2::ggplot() objects, can displayed R via ggplot2::plot.ggplot method. Refer documentation ggplot2-package package detail. plot.file.format Optional character, defaults \"pdf\". Can either \"pdf\", \"jpeg\" \"png\". Specifies file format created output plots (plots saved). Note \"pdf\" use grDevices::cairo_pdf(). plot.width Optional numerical value vector, can length 1 3 must positive entries. Provides width output plots measured unit given plot.unit. plot.width single value, plots use width. Otherwise, plot.width length 3, entry plot.width[1] used width plots trials type \"mono1\", plot.width[2] used trials type \"mono2\" plot.width[3] trials type \"combi.\".plot.width effect parameters plot.unit, plot.width, plot.height defined. case, output plots created specified width length (interpreted given unit measurement). one parameters missing, default device size used. plot.height Optional numerical value vector, can length 1 3 must positive entries. Provides height output plots measured unit given plot.unit. plot.height single value, plots use height. Otherwise, plot.height length 3, entry plot.height[1] used height plots trials type \"mono1\", plot.height[2] used trials type \"mono2\" plot.height[3] trials type \"combi.\". plot.height effect parameters plot.unit, plot.width, plot.height defined. case, output plots created specified width length (interpreted given unit measurement). one parameters missing, default device size used. plot.unit Optional character string, can \"\", \"cm\", \"mm\". Provides unit measurements plot.width plot.height. effect parameters plot.unit, plot.width, plot.height defined. case, output plots created specified width length (interpreted given unit measurement). one parameters missing, default device size used. output.scen.config Optional logical, defaults FALSE. TRUE, results contain necessary specifications evaluated scenario, .e., data scenario, priors, escalation rule specification, seed. Otherwise, posterior summaries returned.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"List. output list entry trial interest provides summary posterior toxicities. output.scen.config TRUE, additional entries give input data included. plot.return plot.decisions TRUE, additional entry created holds list output plots ggplot2::ggplot objects. precisely, following list entries always generated: $trial-[...] , [...] denotes given trial name trials..interest. entry gives matrix lists summary statistics interval probabilities based posterior DLT rate doses interest trial. Additionally, loss escalation active, expected loss dose listed. additionally output.scen.config active, following additional entries: $data Input data used fit joint BLRM. Includes cohorts data historical.data merged data matrix. $prior Contains specified (hyper-)prior distribution used joint BLRM. $configuration Contains remaining configurations, e.g. seed escalation rule. $'Stan options' Contains arguments given Stan, e.g. number MCMC iterations chains. additional plot list generated, entry: $plots List contains output plots ggplot2::ggplot objects. one entry trial, namely $plots$trial-[...] , [...] denotes trial name one trials interest. entry trial either single ggplot2::ggplot object list objects. number entries determined remaining specifications plots. E.g., loss escalation performed, can either just plot expected loss dose, additionally second plot usual interval probabilities. Similarly, trial interest type \"\", 3 plots, one trial type dose levels included (mono 1, mono 2, combination).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"joint BLRM defined according (Neuenschwander et al., 2014 2016). allows perform Bayesian logistic regression estimate dose-toxicity relationship two different monotherapies combination therapy compounds joint model, includes hierarchical prior robust borrowing across trials. following gives brief introduction model, detail refer references provided end documentation page.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"model-specification","dir":"Reference","previous_headings":"","what":"Model specification","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"model assumes, first , treatment dose dose combination \\(d\\) trial \\(j\\) governed toxicity parameter \\(\\pi_j(d)\\), $$r|\\pi_j(d) \\sim Binomial(n, \\pi_j(d))$$ number DLTs, \\(r\\), observed treating cohort \\(n\\) patients dose \\(d\\) trial \\(j\\). toxicity modeled based type treatment. \\(d_i\\) dose compound \\(\\), assumed $$logit(\\pi_j(d)) = log(\\alpha_{ij}) + \\beta_{ij}\\cdot log\\left(\\frac{d_i}{d^*_i}\\right)$$ unknown parameters \\(\\alpha_{ij}>0\\) \\(\\beta_{ij}>0\\) dependent trial \\(j\\) compound \\(\\). Moreover, \\(d^*_i\\) denotes fixed reference dose compound \\(\\). , \\(d=(d_1, d_2)\\) dose combination compounds 1 2, write \\(\\pi_j(d_i)\\) toxicity according monotherapy model, define interaction-free toxicity trial \\(j\\) $$\\pi_{0j}(d_1, d_2) = \\pi_j(d_1) + \\pi_j(d_2) - \\pi_j(d_1)\\cdot \\pi_j(d_2).$$ Based , additional interaction parameter, \\(\\eta_j\\), introduced, combination therapy toxicity interaction modeled $$logit(\\pi_j(d_1, d_2)) = logit(\\pi_{0j}(d_1, d_2)) + \\eta_j \\cdot \\frac{d_1}{d^*_1} \\cdot \\frac{d_2}{d^*_2}.$$ concludes definition likelihood model. following, denote interaction term function $$ g(\\eta, d_1, d_2) = \\eta \\cdot \\frac{d_1}{d^*_1} \\cdot \\frac{d_2}{d^*_2}.$$ -called linear (logit scale) interaction term.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"saturating-interaction-term","dir":"Reference","previous_headings":"","what":"Saturating interaction term","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"Another possibility modeling interaction -called saturating interaction term, performs additional scaling aim addressing potentially problematic behavior linear interaction model case large dose levels. specifically, one \\(\\eta<0\\) considers limit \\(d_i\\rightarrow \\infty\\) (one \\(\\)), holds $$ g(\\eta, d_1, d_2) \\rightarrow -\\infty $$ , consequently, \\(\\pi_j(d_1, d_2) \\rightarrow 0\\). Although seems mostly affecting doses larger reference dose, property may considered realistic, one may want use modified models show behavior. aim, function allows use saturating interaction term instead, follows ideas OncoBayes2::blrm_formula_saturating(), avoid aforementioned phenomenon. saturating interaction term based usual interaction term, includes additional scaling factor dependence dose level, ensures finite limit letting \\(d\\rightarrow \\infty\\). precisely, linear interaction term,\\(g(\\eta, d_1, d_2)\\), exchanged saturating term $$ \\tilde g (\\eta, d_1, d_2) = g(\\eta, d_1, d_2) \\cdot  \\frac{2}{1+\\frac{d_1}{d^*_1} \\cdot \\frac{d_2}{d^*_2}} $$ scaling factor defined whenever \\(d_i=d^*_i\\) \\(\\), saturating interaction term equal usual interaction term, holds \\(\\tilde g (\\eta, d_1, d_2)\\rightarrow 2\\eta\\) \\(d_i\\rightarrow \\infty\\).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"prior-structure-and-prior-choice","dir":"Reference","previous_headings":"","what":"Prior structure and prior choice","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"Regarding prior configuration joint BLRM, denote $$\\theta_j=(log(\\alpha_{1j}), log(\\beta_{1j}), log(\\alpha_{2j}), log(\\beta_{2j}), \\eta_j)$$ trial-specific parameter vector trial \\(j\\). general hierarchical prior assume $$\\theta_j|\\mu,\\Sigma \\sim Normal_5(\\mu, \\Sigma)$$ shared hyper mean vector \\(\\mu\\) shared hyper covariance matrix \\(\\Sigma\\), entries $$\\mu=(\\mu_1, \\mu_2, \\mu_3, \\mu_4, \\mu_5)$$ $$\\Sigma = (\\Sigma_{kl})$$ \\(k=1,...,5\\), \\(l=1,...,5\\). entries \\(\\Sigma_{kl}\\) defined $$\\Sigma_{kk}=\\tau_k\\cdot\\tau_k$$ diagonal, $$\\Sigma_{kl}=\\rho_{kl}\\cdot\\tau_k\\cdot\\tau_l$$ \\(k\\) equal \\(l\\). , \\(\\rho_{kl}\\) correlation coefficients parameters \\(k\\) \\(l\\), \\(\\tau_k\\) standard deviations respective parameters. \\(\\tau_k\\) control standard deviation across parameters different trials, parameters referred -trial heterogeneities. Regarding prior model, suffices specify distributions \\(\\mu_k\\), \\(\\tau_k\\) \\(\\rho_{kl}\\). simplification, assumed entries \\(\\theta_j\\) uncorrelated, except \\(log(\\alpha_{ij})\\) \\(log(\\beta_{ij})\\) (.e., parameters belonging monotherapy compound). , \\(\\rho_{kl}=0\\) \\(kl\\), except \\(\\rho_{12}\\) \\(\\rho_{34}\\). hyperprior distribution correlations, two remaining correlation coefficients \\(\\rho_{12}\\) \\(\\rho_{34}\\) assumed follow \\(Uniform(-1, 1)\\) distributions. Note changed functions scenario_jointBLRM(), sim_jointBLRM(), fit_jointBLRM(). hyper means \\(\\mu_k\\), assumed $$\\mu_k \\sim Normal(m_{\\mu_k}, s_{\\mu_k}^2)$$ fixed mean \\(m_{\\mu_k}\\) standard deviation \\(s_{\\mu_k}\\). values specified prior.mu argument scenario_jointBLRM() sim_jointBLRM(). simplicity, entries list prior.mu vectors length two, contain fixed mean \\(m_{\\mu_k}\\) fixed SD \\(s_{\\mu_k}\\). entries named corresponding parameters, given following overview. reasons readability, use corresponding parameter names subscript writing e.g. \\(\\mu_{\\alpha_1}\\) hypermean \\(log(\\alpha_1)\\). summarized following table. hyper SDs \\(\\tau_k\\), assumed $$\\tau_k \\sim logNormal(m_{\\tau_k}, s_{\\tau_k}^2)$$ fixed mean \\(m_{\\tau_k}\\) standard deviation \\(s_{\\tau_k}\\), given log-scale (, \\(\\tau_k=exp(y)\\) random variable \\(y\\) \\(Normal(m_{\\tau_k}, s_{\\tau_k}^2)\\) distribution). values specified prior.tau argument scenario_jointBLRM() sim_jointBLRM(). simplicity, entries list prior.tau vectors length two, contain fixed mean \\(m_{\\tau_k}\\) fixed SD \\(s_{\\tau_k}\\) log-scale. entries named corresponding parameters, given following overview. See (Neuenschwander et al., 2014 2016) details regarding prior choice.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"escalation-rules","dir":"Reference","previous_headings":"","what":"Escalation rules","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"function supports general three different escalation rules corresponding displays results. context, term \"escalation rule\" refers method used derive concrete dosing recommendations posterior computed BLRM. supported escalation rules escalation overdose control (EWOC) principle, static loss escalation, dynamic loss escalation.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"escalation-with-overdose-control-ewoc-","dir":"Reference","previous_headings":"","what":"Escalation with overdose control (EWOC)","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"EWOC principle goes back Babb et al. (1998) derives dosing recommendations based posterior probability overdosing, overdosing refers DLT rates specified target interval. default, overdosing interval starts therefore 0.33. Formally, EWOC considers posterior distribution \\(\\pi_j(d)\\) DLT rate dose \\(d\\) demands posterior probability \\(\\pi_j(d)\\) lying overdosing interval lower prespecified feasibility bound (defaults 0.25). formula, EWOC condition therefore dose \\(d\\)  trial \\(j\\) (using default values 0.33 0.25 lower boundary overdosing interval feasibility bound): $$ Prob(\\pi_j(d) \\ge 0.33) < 0.25. $$ doses satisfy criterion considered recommendations next dose. obtain concrete dose among remaining levels, one typically demands additional rule. commonly, \"optimal probability rule\" (selecting dose largest probability DLT rate within target interval among levels satisfy EWOC) \"maximal dose rule\" (selecting largest dose satisfies EWOC) chosen. dose combinations, one compounds additionally selected maximized first case draws.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"loss-function-based-escalation","dir":"Reference","previous_headings":"","what":"Loss function-based escalation","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"Static loss escalation goes back Neuenschwander et al. (2008) applies Bayesian decision theory obtain dosing recommendations. , selection dosing recommendation viewed decision problem among different available dose levels different decisions (dose levels) evaluated using formal loss function. define loss function, range DLT rates divided four disjoint dosing intervals, namely, underdosing (interval \\(I_1\\)), target dosing (\\(I_2\\)), excessively toxic dosing (\\(I_3\\)), unacceptably toxic dosing (\\(I_4\\)). contrast EWOC, corresponds dividing overdosing interval two distinct intervals achieve finer differentiation. define formal loss function based intervals, pre-specified penalty value (interval weight), \\(w_i\\), assigned dosing intervals. loss function defined \\(w_i\\) decision dose DLT rate interval \\(I_i\\). desired select doses DLT rate target interval, one typically assume \\(w_2=0\\) remaining penalties positive numbers. dosing recommendation now achieved calculating fixed dose level expected value loss function, -called Bayes risk (expected loss). definition loss function, Bayes risk dose \\(d\\) trial \\(j\\) $$ \\sum_{=1}^4 w_i \\cdot Prob(\\pi_j(d) \\I_i). $$ recommended decision dose minimal Bayes risk among possible doses next cohort. terms pre-specified weights \\(w_i\\), one always set \\(w_2 = 0\\) target interval, remaining weights manual tuning may required cover different situations. Values often work e.g. \\(w_1 = 1\\), \\(w_3 = 1\\), \\(w_4 = 2\\) moderate aggressive escalation decisions,  \\(w_1 = 1\\), \\(w_3 = 2\\), \\(w_4 = 3\\) rather conservative escalation decisions. Note \\(w_1 = 1\\), \\(w_3 = 1\\), \\(w_4 = 1\\) leads decision rule simply maximizes probability lie target interval, found lead overly aggressive decisions simulations according Zhou et al. (2018).","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"dynamic-adjustment-of-loss-function-based-escalation","dir":"Reference","previous_headings":"","what":"Dynamic adjustment of loss function-based escalation","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"Dynamic loss escalation refers heuristic aims adapt pre-specified loss weights method described previous subsection. motivation potential difficulties respect pre-specifying weights ensure appropriate behavior different situations (larger lower true DLT rates), well attempt obtain escalation rule behaves robustly across scenarios, sense obtains good performance settings low DLT rates well settings large ones. Static loss escalation often needs tuned one settings obtain good -trial behavior, may perform poorly settings due . Dynamic loss escalation tries avoid adapting loss weights aggressive conservative configurations using heuristic based observed data posterior. apply dynamic loss escalation, four fixed loss weight combinations $$W_k=(w_{k1}, w_{k2}, w_{k3}, w_{k4})$$ \\(k=1,...,4\\) different degrees aggressiveness need selected. weights normalized sense absolute values \\(W_k\\) must sum number (.e., identical \\(l_1\\) norms). decisions static loss functions invariant linear rescaling weights, one can assume without loss generality weights sum 1. weight adjustment, new loss weights computed prior every decision interpolating fixed weights \\(W_k\\) based current posterior interval probabilities reference dose trial interest. Denote reference dose \\(d^*\\), can either monotherapy dose level (monotherapy trials) dose combination. Now, dosing interval \\(I_i\\), corresponding reference interval probabilities \\(p^*_i\\) computed posterior BLRM, .e., assuming trial \\(j\\) trial interest, compute \\(=1,...,4\\) $$ p^*_i = Prob(\\pi_j(d^*) \\I_i). $$ Using , define current dynamic weight \\(w^*\\) interpolation $$ w^* = p^*_1 * W_1 + p^*_2 * W_2 + p^*_3 * W_3 + p^*_4 * W_4. $$ dynamic weights can now used define formal loss function arrive decision computing dose minimal expected loss based dynamic penalty weights intervals. Intuitively, heuristic assumes reference dose priori assumed likely candidate MTD, typically among larger planned dose levels. , reference dose large probability underdose, dose-toxicity scenario less toxic expected priori, aggressive weight combination can applied. Conversely, reference dose large probability overly toxic, planned dose levels (therefore, investigational treatment) may likely toxic expected priori, conservative configuration interval penalties (larger penalty overdosing intervals) appropriate. Due , weights \\(W_1\\) represent aggressive configuration, \\(W_2\\) \\(W_3\\) moderate conservative configurations, \\(W_4\\) conservative among prespecified weights. Refer parameter documentation dynamic.weights proposed default configuration found work well many situations.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"Stan Development Team (2020). RStan: R interface Stan. R package version 2.21.2. https://mc-stan.org Neuenschwander, B., Branson, M., & Gsponer, T. (2008). Critical aspects Bayesian approach phase cancer trials. Statistics medicine, 27(13), 2420-2439, doi:10.1002/sim.3230. Neuenschwander, B., Matano, ., Tang, Z., Roychoudhury, S., Wandel, S., & Bailey, S. (2014). Bayesian Industry Approach Phase Combination Trials Oncology. : Zhao. W & Yang, H. (editors). Statistical methods drug combination studies. Chapman Hall/CRC, 95-135, doi:10.1201/b17965. Neuenschwander, B., Roychoudhury, S., & Schmidli, H. (2016). use co-data clinical trials. Statistics Biopharmaceutical Research, 8(3), 345-354, doi:10.1080/19466315.2016.1174149. Babb, J., Rogatko, ., & Zacks, S. (1998). Cancer phase clinical trials: Efficient dose escalation overdose control. Statistics medicine 17(10), 1103-1120. Zhou, H.,  Yuan, Y., & Nie, L. (2018). Accuracy, safety, reliability novel phase designs. Clinical Cancer Research, 24(21), 5483-5484 <doi: 10.1158/1078-0432.ccr-18-0168>.","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_jointBLRM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate data from oncology dose finding using a joint BLRM — scenario_jointBLRM","text":"","code":"if (FALSE) { result <- scenario_jointBLRM(                    data=list(dose1 = c(1, 2, 4, 6, 8, 0,  0,  0,  1,  2),                              dose2 = c(0, 0, 0, 0, 0, 10, 20, 30, 10, 10),                              n.pat = c(3, 3, 3, 3, 3, 3,  6,  9,  3,  3),                              n.dlt = c(0, 0, 0, 0, 1, 0,  0,  1,  0,  0),                              trial = c(1, 1, 1, 1, 1, 2,  2,  3,  3,  3)                              ),                    trials.of.interest = c(1,       3),                    types.of.interest =   c(\"mono1\", \"combi\"),                    doses.of.interest = rbind(                      c(1, 2, 4, 6, 8, 12,  rep(c(1, 2, 4, 6, 8, 12),                                                times=3)),                      c(0, 0, 0, 0, 0, 0,   rep(c(10, 20, 30),                                                each = 6 ))),                    dose.ref1 = 12,                    dose.ref2 = 30,                    esc.rule = \"dynamic.loss\",                    prior.mu = list(mu_a1 =  c(logit(0.33), 2),                                    mu_b1 =  c(0,          1),                                    mu_a2 =  c(logit(0.33), 2),                                    mu_b2 =  c(0,          1),                                    mu_eta = c(0,          1.121)),                    prior.tau = list(tau_a1 =  c(log(0.25),  log(2)/1.96),                                     tau_b1 =  c(log(0.125), log(2)/1.96),                                     tau_a2 =  c(log(0.25),  log(2)/1.96),                                     tau_b2 =  c(log(0.125), log(2)/1.96),                                     tau_eta = c(log(0.125), log(2)/1.96)),                    path = getwd(),                    file.name = NULL,                    iter=10000,                    chains=4                    ) }"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_covariate_jointBLRM.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a list of data scenarios including a binary covariate in parallel — scenario_list_covariate_jointBLRM","title":"Process a list of data scenarios including a binary covariate in parallel — scenario_list_covariate_jointBLRM","text":"Wrapper calling scenario_covariate_jointBLRM() list data scenarios, processing parallel. function mostly included convenience, e.g. evaluate number scenarios used prior adjustment quick manner. Please note parallel execution, parallel backend needs registered user. basic example available following vignette: vignette(\"parallelization_jointBLRM\", package = \"decider\"). aware input checks performed scenario_jointBLRM(). results error one scenarios, error returned output list.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_covariate_jointBLRM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a list of data scenarios including a binary covariate in parallel — scenario_list_covariate_jointBLRM","text":"","code":"scenario_list_covariate_jointBLRM(data.list, file.names = NULL, ...)"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_covariate_jointBLRM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a list of data scenarios including a binary covariate in parallel — scenario_list_covariate_jointBLRM","text":"data.list List hypothetical data scenarios. entry passed scenario_jointBLRM(). file.names Optional character vector, defaults NULL. argument effect results saved disk, .e. additional argument path supplied states output location. path supplied file.names NULL, file.name output scenario \\(\\) \"scenario_i\". Otherwise, vector length data.list can supplied file.names, used file name scenario. ... Arguments passed scenario_jointBLRM(), e.g. priors, number MCMC iterations, number chains. Can contain arguments scenario_jointBLRM(), except argument data, taken data.list instead, argument file.name, taken file.names instead. Note particular historical.data can still supplied, included every evaluated scenario, additionally scenario-specific data data.list entries.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_covariate_jointBLRM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a list of data scenarios including a binary covariate in parallel — scenario_list_covariate_jointBLRM","text":"Numbered list entry contains output scenario_jointBLRM() corresponding trial data.list.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_covariate_jointBLRM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process a list of data scenarios including a binary covariate in parallel — scenario_list_covariate_jointBLRM","text":"aware parallelization requires initialization parallel backend user. Otherwise, function executed sequentially.","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_jointBLRM.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a list of data scenarios in parallel. — scenario_list_jointBLRM","title":"Process a list of data scenarios in parallel. — scenario_list_jointBLRM","text":"Wrapper calling scenario_jointBLRM() list data scenarios, processing parallel. function mostly included convenience, e.g. evaluate number scenarios used prior adjustment quick manner. Please note parallel execution, parallel backend needs registered user. basic example available following vignette: vignette(\"parallelization_jointBLRM\", package = \"decider\"). aware input checks performed scenario_jointBLRM(). results error one scenarios, error returned output list.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_jointBLRM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a list of data scenarios in parallel. — scenario_list_jointBLRM","text":"","code":"scenario_list_jointBLRM(data.list, file.names = NULL, ...)"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_jointBLRM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a list of data scenarios in parallel. — scenario_list_jointBLRM","text":"data.list List hypothetical data scenarios. entry passed scenario_jointBLRM(). file.names Optional character vector, defaults NULL. argument effect results saved disk, .e. additional argument path supplied states output location. path supplied file.names NULL, file.name output scenario \\(\\) \"scenario_i\". Otherwise, vector length data.list can supplied file.names, used file name scenario. ... Arguments passed scenario_jointBLRM(), e.g. priors, number MCMC iterations, number chains. Can contain arguments scenario_jointBLRM(), except argument data, taken data.list instead, argument file.name, taken file.names instead. Note particular historical.data can still supplied, included every evaluated scenario, additionally scenario-specific data data.list entries.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_jointBLRM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a list of data scenarios in parallel. — scenario_list_jointBLRM","text":"Numbered list entry contains output scenario_jointBLRM() corresponding trial data.list.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/scenario_list_jointBLRM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process a list of data scenarios in parallel. — scenario_list_jointBLRM","text":"aware parallelization requires initialization parallel backend user. Otherwise, function executed sequentially.","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_covariate_jointBLRM.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate dose-finding trials with covariates — sim_covariate_jointBLRM","title":"Simulate dose-finding trials with covariates — sim_covariate_jointBLRM","text":"Simulates dose-finding trials six parallel monotherapy two-drug combination therapy trials modeled together joint BLRM. function assumes two different compounds involved, compounds 1 2 (combination). two monotherapy trials compound can actively simulated, additionally two combination therapy trials. Additionally, trial binary covariate included model can activated deactivated. general introduction use simulation functions provided package can found introduction vignette:vignette(\"intro_jointBLRM\", package = \"decider\"). Note function sim_covariate_jointBLRM() uses foreach framework allow parallelized simulations. , parallel backend needs registered user. basic example available following vignette: vignette(\"parallelization_jointBLRM\", package = \"decider\"). Please refer scenario_covariate_jointBLRM() details model specification sim_jointBLRM() details arguments used function. Note function sim_covariate_jointBLRM() uses large extent arguments sim_jointBLRM(). additionally added arguments handling binary covariate two_sided1, two_sided2, prior.mu.covar, prior.tau.covar, covar.[...], [...] one trial names, .e. mono1., mono1.b, mono2., mono2.b, combi., combi.b.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_covariate_jointBLRM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate dose-finding trials with covariates — sim_covariate_jointBLRM","text":"","code":"sim_covariate_jointBLRM(    active.mono1.a = FALSE,    active.mono1.b = FALSE,    active.mono2.a = FALSE,    active.mono2.b = FALSE,    active.combi.a = FALSE,    active.combi.b = FALSE,    doses.mono1.a,    doses.mono2.a,    doses.mono1.b,    doses.mono2.b,    doses.combi.a,    doses.combi.b,    dose.ref1,    dose.ref2,    tox.mono1.a,    tox.mono2.a,    tox.combi.a,    tox.mono1.b,    tox.mono2.b,    tox.combi.b,    start.dose.mono1.a,    start.dose.mono2.a,    start.dose.mono1.b,    start.dose.mono2.b,    start.dose.combi.a1,    start.dose.combi.a2,    start.dose.combi.b1,    start.dose.combi.b2,    cohort.queue = rep( c(1,2,3,4,5,6), times= 100),    historical.data = NULL,    esc.rule = \"ewoc\",    esc.comp.max=1,    dosing.intervals = c(0.16, 0.33, 0.6),    ewoc.threshold = 0.25,    loss.weights = c(1, 0, 1, 2),    dynamic.weights =  rbind(        c(0.32, 0, 0.32, 0.36),        c(0.29, 0, 0.31, 0.40),        c(0.27, 0, 0.33, 0.40),        c(0.20, 0, 0.30, 0.50)),    prior.mu = list(        mu_a1 = c(logit(0.33), 2),        mu_b1 = c(0, 1),        mu_a2 = c(logit(0.33), 2),        mu_b2 = c(0, 1),        mu_eta = c(0, 1.121)),    prior.mu.covar = list(        mu_g1 = c(0, 1),        mu_g2 = c(0, 1)),    prior.tau = list(        tau_a1 = c(log(0.25), log(4)/1.96),        tau_b1 = c(log(0.125), log(4)/1.96),        tau_a2 = c(log(0.25), log(4)/1.96),        tau_b2 = c(log(0.125), log(4)/1.96),        tau_eta = c(log(0.125),log(4)/1.96)),    prior.tau.covar = list(        tau_g1 = c(log(0.125),log(4)/1.96),        tau_g2 = c(log(0.125),log(4)/1.96)),    saturating = FALSE,    esc.step = NULL,    esc.step.mono1.a = esc.step,    esc.step.mono2.a = esc.step,    esc.step.mono1.b = esc.step,    esc.step.mono2.b = esc.step,    esc.step.combi.a1 = esc.step,    esc.step.combi.b1 = esc.step,    esc.step.combi.a2 = esc.step,    esc.step.combi.b2 = esc.step,    esc.constrain = FALSE,    esc.constrain.mono1.a=esc.constrain,    esc.constrain.mono2.a=esc.constrain,    esc.constrain.mono1.b=esc.constrain,    esc.constrain.mono2.b=esc.constrain,    esc.constrain.combi.a1=esc.constrain,    esc.constrain.combi.b1=esc.constrain,    esc.constrain.combi.a2=esc.constrain,    esc.constrain.combi.b2=esc.constrain,    cohort.size = c(3),    cohort.size.mono1.a = cohort.size,    cohort.size.mono1.b = cohort.size,    cohort.size.mono2.a = cohort.size,    cohort.size.mono2.b = cohort.size,    cohort.size.combi.a = cohort.size,    cohort.size.combi.b = cohort.size,    cohort.prob = NULL,    cohort.prob.mono1.a = cohort.prob,    cohort.prob.mono1.b = cohort.prob,    cohort.prob.mono2.a = cohort.prob,    cohort.prob.mono2.b = cohort.prob,    cohort.prob.combi.a = cohort.prob,    cohort.prob.combi.b = cohort.prob,    max.n = 42,    max.n.mono1.a = max.n,    max.n.mono1.b = max.n,    max.n.mono2.a = max.n,    max.n.mono2.b = max.n,    max.n.combi.a = max.n,    max.n.combi.b = max.n,    mtd.decision = list(        target.prob = 0.5,        pat.at.mtd = 6,        min.pat = 12,        min.dlt = 1,        rule = 2),    mtd.decision.combi.a = mtd.decision,    mtd.decision.combi.b = mtd.decision,    mtd.decision.mono1.a = mtd.decision,    mtd.decision.mono1.b = mtd.decision,    mtd.decision.mono2.a = mtd.decision,    mtd.decision.mono2.b = mtd.decision,    mtd.enforce = FALSE,    mtd.enforce.mono1.a = mtd.enforce,    mtd.enforce.mono2.a = mtd.enforce,    mtd.enforce.mono1.b = mtd.enforce,    mtd.enforce.mono2.b = mtd.enforce,    mtd.enforce.combi.a = mtd.enforce,    mtd.enforce.combi.b = mtd.enforce,    backfill.mono1.a = FALSE,    backfill.mono1.b = FALSE,    backfill.mono2.a = FALSE,    backfill.mono2.b = FALSE,    backfill.combi.a = FALSE,    backfill.combi.b = FALSE,    backfill.size = c(3),    backfill.prob = NULL,    backfill.size.mono1.a = backfill.size,    backfill.size.mono1.b = backfill.size,    backfill.size.mono2.a = backfill.size,    backfill.size.mono2.b = backfill.size,    backfill.size.combi.a = backfill.size,    backfill.size.combi.b = backfill.size,    backfill.prob.mono1.a = backfill.prob,    backfill.prob.mono1.b = backfill.prob,    backfill.prob.mono2.a = backfill.prob,    backfill.prob.mono2.b = backfill.prob,    backfill.prob.combi.a = backfill.prob,    backfill.prob.combi.b = backfill.prob,    backfill.start.mono1.a = NULL,    backfill.start.mono1.b = NULL,    backfill.start.mono2.a = NULL,    backfill.start.mono2.b = NULL,    backfill.start.combi.a1 = NULL,    backfill.start.combi.a2 = NULL,    backfill.start.combi.b1 = NULL,    backfill.start.combi.b2 = NULL,    two_sided1 = TRUE,    two_sided2 = TRUE,    covar.mono1.a = FALSE,    covar.mono2.a = FALSE,    covar.mono1.b = FALSE,    covar.mono2.b = FALSE,    covar.combi.a = FALSE,    covar.combi.b = FALSE,    n.studies = 1,    seed = sample.int(.Machine$integer.max, 1),    chains = 4,    iter = 13500,    warmup = 1000,    adapt_delta = 0.8,    max_treedepth = 15,    refresh=0,    file.name = NULL,    path = NULL,    monitor.path = NULL,    working.path = NULL,    clean.working.path = FALSE,    output.sim.config =TRUE )"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_covariate_jointBLRM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate dose-finding trials with covariates — sim_covariate_jointBLRM","text":"active.mono1., active.mono1.b, active.mono2., active.mono2.b, active.combi., active.combi.b Logicals, default FALSE. Refer sim_jointBLRM() details. doses.mono1., doses.mono1.b, doses.mono2., doses.mono2.b Numericals, one dimensional vectors positive, strictly ascending entries. Refer sim_jointBLRM() details. doses.combi., doses.combi.b Numericals, two dimensional arrays two rows, arbitrarily many columns, positive entries. Refer sim_jointBLRM() details. dose.ref1 Positive numerical value. Reference dose compound 1. dose.ref2 Positive numerical value. Reference dose compound 2. tox.mono1., tox.mono1.b, tox.mono2., tox.mono2.b Numericals, one dimensional vectors entries \\((0,1)\\). Refer sim_jointBLRM() details. tox.combi., tox.combi.b Numericals, one dimensional vectors entries \\((0,1)\\). Refer sim_jointBLRM() details. start.dose.mono1., start.dose.mono2., start.dose.mono1.b, start.dose.mono2.b Positive numerical values specify starting dose simulated monotherapy trials. Refer sim_jointBLRM() details. start.dose.combi.a1, start.dose.combi.a2, start.dose.combi.b1, start.dose.combi.b2 Positive numerical values specify starting dose simulated combination therapy trials. Refer sim_jointBLRM() details. cohort.queue Optional numerical character vector specifies order pattern cohorts enrolled simulated trials. Refer sim_jointBLRM() details. historical.data Optional parameter must NULL (default) named list specifies historical data included trial. Refer sim_jointBLRM() details, scenario_covariate_jointBLRM() required input format historical data. esc.rule Optional character string, must one following values: \"ewoc\", \"ewoc.opt\", \"ewoc.max\". Refer sim_jointBLRM() details. esc.comp.max Optional integer, must either 1 (default) 2. Refer sim_jointBLRM() details. dosing.intervals Optional numeric vector ascending entries 0 1. Refer sim_jointBLRM() details. ewoc.threshold Optional numerical value 0 1 (excluding boundaries), defaults 0.25. Refer sim_jointBLRM() details. loss.weights Optional numerical vector four entries (can arbitrary numbers), default c(1,0,1,2). Refer sim_jointBLRM() details. dynamic.weights Optional numerical matrix four rows four columns, arbitrary numbers entries. Refer sim_jointBLRM() details. prior.mu Optional list gives prior distribution hyper means \\(\\mu\\). Refer sim_jointBLRM() details. prior.mu.covar Optional named list gives prior distribution hyper-means additional parameters included joint BLRM realize binary covariate. Refer scenario_covariate_jointBLRM() details. prior.tau Optional list gives prior distribution -trial heterogeneities (hyper SD) \\(\\tau\\). Refer sim_jointBLRM() details. prior.tau.covar Optional named list gives prior distribution -trial heterogeneities additional parameters included joint BLRM realize binary covariate. Refer scenario_covariate_jointBLRM() details. saturating Optional logical, defaults FALSE. Refer sim_jointBLRM() details. esc.step, esc.step.mono1., esc.step.mono2., esc.step.combi.a1, esc.step.combi.a2 Optional numerical values specify maximum factor dose escalations demanded additionally selected escalation rule. Refer sim_jointBLRM() details. esc.step.mono1.b, esc.step.mono2.b, esc.step.combi.b1, esc.step.combi.b2 esc.step.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. esc.constrain, esc.constrain.mono1., esc.constrain.mono2.Optional logicals, default FALSE. Refer sim_jointBLRM() details. esc.constrain.mono1.b, esc.constrain.mono2.b, esc.constrain.combi.b1, esc.constrain.combi.b2 esc.constrain.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. esc.constrain.combi.a1, esc.constrain.combi.a2 Optional logicals, default FALSE. Refer sim_jointBLRM() details. cohort.size, cohort.size.mono1., cohort.size.mono2., cohort.size.combi.Optional positive integer vectors specify available cohort sizes simulated cohorts. Refer sim_jointBLRM() details. cohort.size.mono1.b, cohort.size.mono2.b, cohort.size.combi.b cohort.size.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. cohort.prob, cohort.prob.mono1., cohort.prob.mono2., cohort.prob.combi.Optional positive numeric vectors values 0 1 specify probability available cohort sizes corresponding argument cohort.size.[...]. Refer sim_jointBLRM() details. cohort.prob.mono1.b, cohort.prob.mono2.b, cohort.prob.combi.b cohort.prob.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. max.n, max.n.mono1., max.n.mono2., max.n.combi.Optional positive integer values specify maximum number patients enrolled simulated trials. Refer sim_jointBLRM() details. max.n.mono1.b, max.n.mono2.b, max.n.combi.b max.n.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. mtd.decision, mtd.decision.mono1., mtd.decision.mono2., mtd.decision.combi.Optional named lists specify rules MTD selection. Refer sim_jointBLRM() details. mtd.decision.mono1.b, mtd.decision.mono2.b, mtd.decision.combi.b mtd.decision.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. mtd.enforce, mtd.enforce.mono1., mtd.enforce.mono2., mtd.enforce.combi.Optional logicals, default FALSE. Refer sim_jointBLRM() details. mtd.enforce.mono1.b, mtd.enforce.mono2.b, mtd.enforce.combi.b mtd.enforce.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. backfill.mono1., backfill.mono2., backfill.combi.Optional logicals, indicating whether back-fill cohorts simulated trial. backfill.mono1.b, backfill.mono2.b, backfill.combi.b backfill.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. backfill.size, backfill.size.mono1., backfill.size.mono2., backfill.size.combi.Optional numericals, provide size simulated back-fill cohorts. Interpreted fashion cohort.size. backfill.prob, backfill.prob.mono1., backfill.prob.mono2., backfill.prob.combi.Optional numericals, provide probabilities multiple possible back-fill cohort sizes given. Interpreted fashion cohort.prob. backfill.size.mono1.b, backfill.size.mono2.b, backfill.size.combi.b backfill.size.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. backfill.prob.mono1.b, backfill.prob.mono2.b, backfill.prob.combi.b backfill.prob.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. backfill.start.mono1., backfill.start.mono2., backfill.start.combi.a1, backfill.start.combi.a2 Optional numericals. Specify first dose back-fill cohorts enrolled. provided, lowest available dose assumed starting point back-fill cohorts respective trial. backfill.start.mono1.b, backfill.start.mono2.b, backfill.start.combi.b1, backfill.start.combi.b2 backfill.start.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. two_sided1 Optional logical, defaults TRUE. Refer scenario_covariate_jointBLRM() details. two_sided2 Optional logical, defaults TRUE. Refer scenario_covariate_jointBLRM() details. covar.mono1., covar.mono1.b, covar.mono2., covar.mono2.b, covar.combi., covar.combi.b Optional logicals, default FALSE. Specify whether corresponding simulated trial value 0 1 binary covariate. Set covar.[...]=TRUE trial shall covariate 1. default, trials property indicated binary covariate. equivalent joint BLRM without covariate. n.studies Positive integer specifies number studies simulated, defaults 1. Refer sim_jointBLRM() details. seed Optional positive integer specified seed used simulation. Refer sim_jointBLRM() details. chains Optional positive integer specifies number Markov chains used MCMC sampling, defaults 4. Refer sim_jointBLRM() details. iter Optional positive integer specifies total number iterations per chain used MCMC sampling, defaults 13500. Refer sim_jointBLRM() details. warmup Optional positive integer specifies number iterations per chain discarded total number iterations, iter. Defaults 1000. Refer sim_jointBLRM() details. adapt_delta Optional numerical must least 0.6 smaller 1, defaults 0.8. Refer sim_jointBLRM() details. max_treedepth Optional integer must least 10, defaults 15. Refer sim_jointBLRM() details. refresh Optional integer, defaults 0. Refer sim_jointBLRM() details. file.name Optional character string provides name potential output files. Refer sim_jointBLRM() details. path Optional character string specifies path output directory. Refer sim_jointBLRM() details. monitor.path Optional character string specifies path additional output directory monitoring simulation progress. Refer sim_jointBLRM() details. working.path Optional character string specifies path directory temporary results. Refer sim_jointBLRM() details. clean.working.path Optional logical, defaults FALSE. Refer sim_jointBLRM() details. output.sim.config Optional logical specifies whether input parameters call sim_jointBLRM() added output list. Refer sim_jointBLRM() details.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_covariate_jointBLRM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate dose-finding trials with covariates — sim_covariate_jointBLRM","text":"List contains number metrics summarize results simulation simulated trial, , depending specification, additional list entries save given input specification. default, following list entries generated simulated trial ([...] corresponding suffix trial): ...$'results [...]' Overview number MTDs per dosing interval (, target, ), number trials stopped without finding MTD, either due stopping rule (EWOC-based escalation used) due reaching maximal patient number. ...$'summary [...]' Summary statistics (mean, median, min, max, 2.5% 97.5% quantile) number patients, patients per dosing interval, DLTs, DLTs per dosing interval. ...$'MTDs [...]' Number MTDs per dose level assumed DLT rates. ...$'#pat [...]' Mean, median, minimum maximum number patients enrolled dose level. Additionally, output.sim.config active, list include following entries: ...$'historical.data' included historical data included simulations. Contains specified cohorts historical data. ...$'prior' prior distribution hyper-parameters used BLRM. ...$'specifications' simulation specifications. Includes e. g. reference doses, decision rules, escalation steps, seed. ...$'Stan options' Options given Stan, number MCMC iterations chains.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_covariate_jointBLRM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate dose-finding trials with covariates — sim_covariate_jointBLRM","text":"joint BLRM defined according (Neuenschwander et al., 2014 2016). allows perform Bayesian logistic regression estimate dose-toxicity relationship two different monotherapies combination therapy compounds joint model, includes hierarchical prior robust borrowing across trials. Refer documentation scenario_jointBLRM() detailed model description. , refer documentation scenario_covariate_jointBLRM() description model including covariates.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_covariate_jointBLRM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate dose-finding trials with covariates — sim_covariate_jointBLRM","text":"Stan Development Team (2020). RStan: R interface Stan. R package version 2.21.2. https://mc-stan.org. Neuenschwander, B., Branson, M., & Gsponer, T. (2008). Critical aspects Bayesian approach phase cancer trials. Statistics medicine, 27(13), 2420-2439, doi:10.1002/sim.3230. Neuenschwander, B., Matano, ., Tang, Z., Roychoudhury, S., Wandel, S., & Bailey, S. (2014). Bayesian Industry Approach Phase Combination Trials Oncology. : Zhao. W & Yang, H. (editors). Statistical methods drug combination studies. Chapman Hall/CRC, 95-135, doi:10.1201/b17965. Neuenschwander, B., Roychoudhury, S., & Schmidli, H. (2016). use co-data clinical trials. Statistics Biopharmaceutical Research, 8(3), 345-354, doi:10.1080/19466315.2016.1174149. Babb, J., Rogatko, ., & Zacks, S. (1998). Cancer phase clinical trials: Efficient dose escalation overdose control. Statistics medicine 17(10), 1103-1120. Zhou, H.,  Yuan, Y., & Nie, L. (2018). Accuracy, safety, reliability novel phase designs. Clinical Cancer Research, 24(21), 5483-5484 <doi: 10.1158/1078-0432.ccr-18-0168>.","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_jointBLRM.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate dose-finding trials — sim_jointBLRM","title":"Simulate dose-finding trials — sim_jointBLRM","text":"Simulates dose-finding trials six parallel monotherapy two-drug combination therapy trials modeled together joint BLRM. function assumes two different compounds involved, compounds 1 2 (combination). two monotherapy trials compound can actively simulated, additionally two combination therapy trials. Note term \"trial\" can context also refer trial arms (e.g. monotherapy combination therapy), underlying model differentiate notions. order cohorts simulated trials enrolled can specified freely. , besides actively simulated trials, function supports inclusion historical data arbitrarily many previous (already concluded) dose-finding trials considered compounds. introduction use function, see introduction vignette: vignette(\"intro_jointBLRM\", package = \"decider\"). Note function sim_jointBLRM() uses foreach framework allow parallelized simulations. , parallel backend needs registered user. basic example available following vignette: vignette(\"parallelization_jointBLRM\", package = \"decider\"). function expects specification dose levels assumed DLT rates involved trial, based course dose-finding trial simulated. Additional customization simulations possible (separately simulated trial), e.g. regarding escalation rule (EWOC loss-based methods), definition MTD, maximum increment escalations, numbers patients per cohort, specifications. six possible trials encoded following suffixes: mono1., mono1.b, mono2., mono2.b, combi., combi.b. ending (..b) differentiates two different trials kind, .e., monotherapy compound 1 (mono1), monotherapy compound 2 (mono2), combination therapy (combi). function arguments, one version argument available trial (differentiated via suffixes), different simulated trials may use different specifications terms e.g. dose levels, assumed DLT rate, starting dose. differentiate six simulated trials actual simulation run processes one realization activated trials, following use term \"study\" single simulation run determines realization activated trial using given specifications. instance, two trials active, say mono1.combi., term \"trial\" refers simulated trials names, notion \"study\" means simulation run trials specified order given input assumptions. Simulating e.g. 1000 studies means context trials mono1.combi.simulated specified order using specified options 1000 times. parameters sensible defaults often need specified explicitly. recommended workflow set function follows: Specify reference doses. Optional: Specify available historical data , needed, specific priors model (default ones weakly informative). Specify dose levels, starting doses assumed DLT rates trial needs simulated, activate corresponding trials via active.[...] arguments. Set number trials simulated. Optional: Specify additional options simulations. Optional: Register parallel backend foreach framework, cf. foreach-package. Alternatively additionally, small number cores available, consider supply path working directory saving re-loading MCMC results. working directory supplied, aware function may delete modify existing .RData files containing \"_tmp\" supplied file.name name working directory avoid re-loading MCMC runs previous simulations. Refer documentation detail. Run simulation. Note simulations e.g. 1000 trials may take multiple hours depending specifications.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_jointBLRM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate dose-finding trials — sim_jointBLRM","text":"","code":"sim_jointBLRM(    active.mono1.a = FALSE,    active.mono1.b = FALSE,    active.mono2.a = FALSE,    active.mono2.b = FALSE,    active.combi.a = FALSE,    active.combi.b = FALSE,    doses.mono1.a,    doses.mono2.a,    doses.mono1.b,    doses.mono2.b,    doses.combi.a,    doses.combi.b,    dose.ref1,    dose.ref2,    tox.mono1.a,    tox.mono2.a,    tox.combi.a,    tox.mono1.b,    tox.mono2.b,    tox.combi.b,    start.dose.mono1.a,    start.dose.mono2.a,    start.dose.mono1.b,    start.dose.mono2.b,    start.dose.combi.a1,    start.dose.combi.a2,    start.dose.combi.b1,    start.dose.combi.b2,    cohort.queue = rep( c(1,2,3,4,5,6), times= 100),    historical.data = NULL,    esc.rule = \"ewoc\",    esc.comp.max=1,    dosing.intervals = c(0.16, 0.33, 0.6),    ewoc.threshold = 0.25,    loss.weights = c(1, 0, 1, 2),    dynamic.weights =  rbind(        c(0.32, 0, 0.32, 0.36),        c(0.29, 0, 0.31, 0.40),        c(0.27, 0, 0.33, 0.40),        c(0.20, 0, 0.30, 0.50)),    prior.mu = list(        mu_a1 = c(logit(0.33), 2),        mu_b1 = c(0, 1),        mu_a2 = c(logit(0.33), 2),        mu_b2 = c(0, 1),        mu_eta = c(0, 1.121)),    prior.tau = list(        tau_a1 = c(log(0.25), log(4)/1.96),        tau_b1 = c(log(0.125), log(4)/1.96),        tau_a2 = c(log(0.25), log(4)/1.96),        tau_b2 = c(log(0.125), log(4)/1.96),        tau_eta = c(log(0.125),log(4)/1.96)),    saturating = FALSE,    esc.step = NULL,    esc.step.mono1.a = esc.step,    esc.step.mono2.a = esc.step,    esc.step.mono1.b = esc.step,    esc.step.mono2.b = esc.step,    esc.step.combi.a1 = esc.step,    esc.step.combi.b1 = esc.step,    esc.step.combi.a2 = esc.step,    esc.step.combi.b2 = esc.step,    esc.constrain = FALSE,    esc.constrain.mono1.a=esc.constrain,    esc.constrain.mono2.a=esc.constrain,    esc.constrain.mono1.b=esc.constrain,    esc.constrain.mono2.b=esc.constrain,    esc.constrain.combi.a1=esc.constrain,    esc.constrain.combi.b1=esc.constrain,    esc.constrain.combi.a2=esc.constrain,    esc.constrain.combi.b2=esc.constrain,    cohort.size = c(3),    cohort.size.mono1.a = cohort.size,    cohort.size.mono1.b = cohort.size,    cohort.size.mono2.a = cohort.size,    cohort.size.mono2.b = cohort.size,    cohort.size.combi.a = cohort.size,    cohort.size.combi.b = cohort.size,    cohort.prob = NULL,    cohort.prob.mono1.a = cohort.prob,    cohort.prob.mono1.b = cohort.prob,    cohort.prob.mono2.a = cohort.prob,    cohort.prob.mono2.b = cohort.prob,    cohort.prob.combi.a = cohort.prob,    cohort.prob.combi.b = cohort.prob,    max.n = 42,    max.n.mono1.a = max.n,    max.n.mono1.b = max.n,    max.n.mono2.a = max.n,    max.n.mono2.b = max.n,    max.n.combi.a = max.n,    max.n.combi.b = max.n,    mtd.decision = list(        target.prob = 0.5,        pat.at.mtd = 6,        min.pat = 12,        min.dlt = 1,        rule = 2),    mtd.decision.combi.a = mtd.decision,    mtd.decision.combi.b = mtd.decision,    mtd.decision.mono1.a = mtd.decision,    mtd.decision.mono1.b = mtd.decision,    mtd.decision.mono2.a = mtd.decision,    mtd.decision.mono2.b = mtd.decision,    mtd.enforce = FALSE,    mtd.enforce.mono1.a = mtd.enforce,    mtd.enforce.mono2.a = mtd.enforce,    mtd.enforce.mono1.b = mtd.enforce,    mtd.enforce.mono2.b = mtd.enforce,    mtd.enforce.combi.a = mtd.enforce,    mtd.enforce.combi.b = mtd.enforce,    backfill.mono1.a = FALSE,    backfill.mono1.b = FALSE,    backfill.mono2.a = FALSE,    backfill.mono2.b = FALSE,    backfill.combi.a = FALSE,    backfill.combi.b = FALSE,    backfill.size = c(3),    backfill.prob = NULL,    backfill.size.mono1.a = backfill.size,    backfill.size.mono1.b = backfill.size,    backfill.size.mono2.a = backfill.size,    backfill.size.mono2.b = backfill.size,    backfill.size.combi.a = backfill.size,    backfill.size.combi.b = backfill.size,    backfill.prob.mono1.a = backfill.prob,    backfill.prob.mono1.b = backfill.prob,    backfill.prob.mono2.a = backfill.prob,    backfill.prob.mono2.b = backfill.prob,    backfill.prob.combi.a = backfill.prob,    backfill.prob.combi.b = backfill.prob,    backfill.start.mono1.a = NULL,    backfill.start.mono1.b = NULL,    backfill.start.mono2.a = NULL,    backfill.start.mono2.b = NULL,    backfill.start.combi.a1 = NULL,    backfill.start.combi.a2 = NULL,    backfill.start.combi.b1 = NULL,    backfill.start.combi.b2 = NULL,    n.studies = 1,    seed = sample.int(.Machine$integer.max, 1),    chains = 4,    iter = 13500,    warmup = 1000,    adapt_delta = 0.8,    max_treedepth = 15,    refresh=0,    file.name = NULL,    path = NULL,    monitor.path = NULL,    working.path = NULL,    clean.working.path = FALSE,    output.sim.config =TRUE )"},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_jointBLRM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate dose-finding trials — sim_jointBLRM","text":"active.mono1., active.mono1.b, active.mono2., active.mono2.b, active.combi., active.combi.b Logicals, default FALSE. parameter activates simulation corresponding trial. parameter FALSE, corresponding trial simulated, parameters suffix ignored, historical information can included trial. doses.mono1., doses.mono1.b, doses.mono2., doses.mono2.b Numericals, one dimensional vectors positive, strictly ascending entries. vector indicates dose levels corresponding monotherapy trial. Optional active.[...] FALSE corresponding suffix. doses.combi., doses.combi.b Numericals, two dimensional arrays two rows, arbitrarily many columns, positive entries. need ascending. column indicates combination dose level corresponding combination therapy trial, entry first row specific column gives dose level compound 1, entry second row dose level compound 2. Optional active.combi.[...] FALSE corresponding suffix. dose.ref1 Positive numerical value. Reference dose compound 1. dose.ref2 Positive numerical value. Reference dose compound 2. tox.mono1., tox.mono1.b, tox.mono2., tox.mono2.b Numericals, one dimensional vectors entries \\((0,1)\\).  Optional active.mono.[...] FALSE corresponding suffix. Otherwise, must length doses.[...] corresponding suffix. entry \\(\\) specifies DLT rate dose \\(\\) corresponding trial. tox.combi., tox.combi.b Numericals, one dimensional vectors entries \\((0,1)\\).  Optional active.combi.[...] FALSE corresponding suffix. Otherwise, length must equal number columns doses.combi.[...]. entry \\(\\) specifies DLT rate dose combination row \\(\\) doses.combi.[...]. start.dose.mono1., start.dose.mono2., start.dose.mono1.b, start.dose.mono2.b Positive numerical values specify starting dose simulated monotherapy trials. value start.dose.mono.[...] must one entries doses.mono.[...] corresponding suffix. starting doses optional corresponding trial activated. start.dose.combi.a1, start.dose.combi.a2, start.dose.combi.b1, start.dose.combi.b2 Positive numerical values specify starting dose simulated combination therapy trials. values suffixes .a1  .a2 define starting dose first second compound combi.trial, must appear combination one columns doses.combi.. applies trial suffix combi.b. starting doses optional corresponding trial activated. cohort.queue Optional numerical character vector specifies order pattern cohorts enrolled simulated trials. default, cohorts enrolled sequentially order: mono1., mono2., combi., mono1.b, mono2.b, combi.b, repeated trials concluded. general, entry \\(\\) specifies simulated trial \\(\\)th simulated cohort enrolled (provided trial concluded yet, case entry ignored). cohort.queue can therefore used express e.g. certain number monotherapy cohorts completed prior start combination therapy trial. cohort.queue can either short pattern repeated automatically, alternatively long vector contains already order cohorts may occur trial. latter can e.g. used ensure trial concluded prior start trial supplying enough cohorts former reach maximum sample size first cohort latter trial enrolled. trials cohorts assigned encoded follows: \"mono1.\" 1 Corresponds cohort mono1.trial (monotherapy trial compound 1). \"mono2.\" 2 Corresponds cohort mono2.trial (monotherapy trial compound 2). \"combi.\" 3 Corresponds cohort combi.trial (combination therapy trial). \"mono1.b\" 4 Corresponds cohort mono1.b trial (monotherapy trial compound 1). \"mono2.b\" 5 Corresponds cohort mono2.b trial (monotherapy trial compound 2). \"combi.b\" 6 Corresponds cohort combi.b trial (combination therapy trial). Assuming cohort assigned minimal possible cohort size (specified via argument cohort.size), cohort.queue contain sufficiently many entries activated trial can principle reach specified maximum patient number enrolled trial. instance, cohorts consist 3 patients maximum sample size (given max.n.[...]) trial 30, trial appear least 10 times cohort queue. case, function repeat cohort queue sufficiently many cohorts contained. historical.data Optional parameter must NULL (default) named list specifies historical data included trial. Historical data can included purely historical trials (.e., actively simulated) also directly one simulated trials (case simulation assumes data previously recorded corresponding trial). value NULL represents historical data available. Otherwise, historical data specified via named list entries dose1, dose2, n.pat, n.dlt, trial (names case-sensitive). list entries vectors whose length equal number historical cohorts included. format follows: historical.data$dose1 Numerical vector non-negative NA entries. Entry \\(\\) gives dose level compound 1 administered \\(\\)th historical cohort. compound 1 administered cohort, entry 0 NA. historical.data$dose2 Numerical vector non-negative NA entries. Entry \\(\\) gives dose level compound 2 administered \\(\\)th historical cohort. compound 2 administered cohort, entry 0 NA. historical.data$n.pat Numerical vector non-negative entries. Entry \\(\\) gives number patients \\(\\)th historical cohort. patient number 0, historical cohort removed automatically. NA entries permitted. historical.data$n.dlt Numerical vector non-negative entries. Entry \\(\\) gives number patients experienced DLT among \\(\\)th historical cohort. number DLTs allowed larger number patients cohort. NA entries permitted. historical.data$trial Numerical character vector arbitrary entries (except NA permitted). Entry \\(\\) gives code trial \\(\\)th historical cohort arises. , historical patients grouped different historical concurrent trials according values, entries case sensitive differentiate numbers converted strings (.e., 42 \"42\" represent trial). following entries reserved represent cohort belongs one actively simulated trials: \"mono1.\" 1 cohort assumed belong actively simulated trial mono1.. \"mono2.\" 2 cohort assumed belong actively simulated trial mono2.. \"combi.\" 3 cohort assumed belong actively simulated trial combi.. \"mono1.b\" 4 cohort assumed belong actively simulated trial mono1.b. \"mono2.b\" 5 cohort assumed belong actively simulated trial mono2.b. \"combi.b\" 6 cohort assumed belong actively simulated trial combi.b. esc.rule Optional character string, must one following values: \"ewoc\", \"ewoc.opt\", \"ewoc.max\", \"loss\", \"dynamic\", \"dynamic.loss\", default \"ewoc\". value esc.rule specifies escalation rule applied simulation, cf. Details. character strings interpreted case-insensitive fashion. possible values interpreted follows: \"ewoc\" \"ewoc.opt\" Applies EWOC criterion optimal probability rule three dosing intervals (underdosing, target dosing, overdosing). , next dose one largest probability true DLT rate lies target interval among doses whose probability DLT rate overdosing interval lower feasibility bound specified argument ewoc.threshold. multiple doses dose combinations attain maximum target probability satisfy EWOC principle, escalation rule additionally maximize dose level compound specified argument esc.comp.max. \"ewoc.max\" Applies EWOC criterion maximum dose rule three dosing intervals (underdosing, target dosing, overdosing). , next dose largest one among doses whose probability true DLT rate overdosing interval lower feasibility bound specified argument ewoc.threshold. dose combinations, escalation rule first maximize compound specified esc.comp.max, afterwards compound. \"loss\" Applies static loss escalation rule using weights specified argument loss.weights four dosing intervals (dosing, target dosing, excessive toxicity, unacceptable toxicity). multiple dose combinations result expected loss (Bayes risk), function additionally maximize compound specified argument esc.comp.max among doses minimum expected loss. \"dynamic\" \"dynamic.loss\" Applies dynamic loss escalation rule using weights specified argument dynamic.weights four dosing intervals (dosing, target dosing, excessive toxicity, unacceptable toxicity). multiple dose combinations result expected loss (Bayes risk), function additionally maximize compound specified argument esc.comp.max among doses minimum expected loss. esc.comp.max Optional integer, must either 1 (default) 2. value specifies compound (1 2) maximized first escalation rule leads draw among multiple dose combinations. dosing.intervals Optional numeric vector ascending entries 0 1. argument dosing.intervals must length 1, 2, 3, defines boundaries dosing intervals used escalation decisions. default c(0.16, 0.33, 0.6) can used escalation rule. interpretation requirements vary slightly across different escalation rules (different values esc.rule). precisely, following cases differentiated. esc.rule ... \"ewoc\",\"ewoc.max\", \"ewoc.opt\" length can either 1, 2, 3. latter two cases, first two entries used specify targeted dosing interval. , target interval assumed range dosing.intervals[1] dosing.intervals[2], potential third entry discarded. dosing.intervals length 1 value x, argument internally transformed c(0, x). , target interval assumed range 0 x, underdosing interval considered. overdosing interval implicitly defined range dosing.intervals[2] 1, underdosing interval defined range 0 dosing.intervals[1]. \"loss\",\"dynamic.loss\", \"dynamic\" Must three entries used specify targeted dosing interval interval excessively toxic dosing. , target interval assumed range dosing.intervals[1] dosing.intervals[2], interval excessively toxic dosing assumed range dosing.intervals[2] dosing.intervals[3]. underdosing interval therefore implicitly defined range  0 dosing.intervals[1], unacceptably toxic dosing interval implicitly defined range dosing.intervals[3] 1. ewoc.threshold Optional numerical value 0 1 (excluding boundaries), defaults 0.25. Defines feasibility bound EWOC criterion, .e., esc.rule one EWOC-based rules, next dose must probability DLT rate overdosing interval lower ewoc.threshold. value ignored esc.rule specifies one loss-based escalation rules. loss.weights Optional numerical vector four entries (can arbitrary numbers), default c(1,0,1,2). Specifies interval weights/penalties used static loss escalation. needed esc.rule \"loss\", parameter ignored otherwise. precisely, loss.weights[1] weight underdosing interval, loss.weights[2] weight  target dosing interval, loss.weights[3] weight excessively toxic dosing interval, loss.weights[4] weight unacceptably toxic dosing interval. See Details section explanations regarding methodology. dynamic.weights Optional numerical matrix four rows four columns, arbitrary numbers entries.  Specifies interval weights/penalties used dynamic loss escalation. needed esc.rule \"dynamic\" \"dynamic.loss\", parameter ignored otherwise. row dynamic.weights specifies one static loss weight vectors interpolated dynamic loss escalation. See Details section explanations regarding methodology. precisely, dynamic.weights[1, ] static weight vector weighted posterior probability reference dose true DLT rate underdose interval, dynamic.weights[2, ] static weight vector weighted posterior probability reference dose true DLT rate target interval, dynamic.weights[3, ] static weight vector weighted posterior probability reference dose true DLT rate excessively toxic dosing interval, dynamic.weights[4, ] static weight vector weighted posterior probability reference dose true DLT rate unacceptably toxic dosing interval. default value dynamic.weights matrix following four rows (order): c(0.32, 0, 0.32, 0.36), c(0.29, 0, 0.31, 0.40), c(0.27, 0, 0.33, 0.40), c(0.20, 0, 0.30, 0.50). prior.mu Optional list gives prior distribution hyper means \\(\\mu\\). list must named entries, need numeric vectors length 2: prior.mu$mu_a1 Numeric length two, defaults c(logit(0.33), 2). Specifies mean SD hypermean \\(\\mu_1\\) parameter \\(log(\\alpha_1)\\) BLRM. second entry must therefore positive. See Details section detail. prior.mu$mu_b1 Numeric length two, defaults c(0, 1). Specifies mean SD hypermean \\(\\mu_2\\) parameter \\(log(\\beta_1)\\) BLRM. second entry must therefore positive. See Details section detail. prior.mu$mu_a2 Numeric length two, defaults c(logit(0.33), 2). Specifies mean SD hypermean \\(\\mu_3\\) parameter \\(log(\\alpha_2)\\) BLRM. second entry must therefore positive. See Details section detail. prior.mu$mu_b2 Numeric length two, defaults c(0, 1). Specifies mean SD hypermean \\(\\mu_4\\) parameter \\(log(\\beta_2)\\) BLRM. second entry must therefore positive. See Details section detail. prior.mu$mu_eta Numeric length two, defaults c(0, 1.121). Specifies mean SD hypermean \\(\\mu_5\\) parameter \\(\\eta\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau Optional list gives prior distribution -trial heterogeneities (hyper SD) \\(\\tau\\). list must named entries, need numeric vectors length 2: prior.tau$tau_a1 Numeric length two, defaults c(log(0.25), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_1\\) parameter \\(log(\\alpha_1)\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau$tau_b1 Numeric length two, defaults c(log(0.125), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_2\\) parameter \\(log(\\beta_1)\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau$tau_a2 Numeric length two, defaults c(log(0.25), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_3\\) parameter \\(log(\\alpha_2)\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau$tau_b2 Numeric length two, defaults c(log(0.125), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_4\\) parameter \\(log(\\beta_2)\\) BLRM. second entry must therefore positive. See Details section detail. prior.tau$tau_eta Numeric length two, defaults c(log(0.125), log(2)/1.96). Specifies mean SD log-scale heterogeneity \\(\\tau_5\\) parameter \\(\\eta\\) BLRM. second entry must therefore positive. See Details section detail. saturating Optional logical, defaults FALSE. TRUE, BLRM using saturating interaction term described OncoBayes2::blrm_formula_saturating(). Also refer Details section documentation scenario_jointBLRM(). esc.step, esc.step.mono1., esc.step.mono2., esc.step.combi.a1, esc.step.combi.a2 Optional numerical values specify maximum factor dose escalations demanded additionally selected escalation rule. default NULL, case escalation step determined automatically corresponding trial (activated) maximum factor (sorted) available doses trial. example, value esc.step=2 indicates dose can doubled, , words, increment subsequent dose levels 100%. argument esc.step global variant, escalation steps specified user default value. particular, trials shall use escalation factor, value esc.step needs defined, trial-specific variants can used express specific trial shall deviate global parameter. Note consistency checks performed parameters, .e., whether specified escalation step allows reach available doses. value esc.step.[...] gives escalation step used corresponding trial. Note two escalation steps combination therapy trials: instance, esc.step.combi.a1 gives maximum escalation factor first compound combination therapy escalations, esc.step.combi.a2 defines escalation step second compound. esc.step.mono1.b, esc.step.mono2.b, esc.step.combi.b1, esc.step.combi.b2 esc.step.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. esc.constrain, esc.constrain.mono1., esc.constrain.mono2.Optional logicals, default FALSE. TRUE, escalation decisions corresponding trial constrained available dose levels, sense next larger dose can used next cohort. apply de-escalation, arbitrary lower dose levels allowed. Note esc.constrain[...] overrules esc.step[...], given escalation step ignored esc.constrain[...] TRUE. , esc.contrain global variant affects trials. specific trial shall deviate global setting, needs activated specifically trial specific variant esc.constrain.[...] using corresponding suffix. esc.constrain.mono1.b, esc.constrain.mono2.b, esc.constrain.combi.b1, esc.constrain.combi.b2 esc.constrain.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. esc.constrain.combi.a1, esc.constrain.combi.a2 Optional logicals, default FALSE. Work way esc.constrain.mono[...], except compounds combination therapy trial constrained separately , e.g. esc.constrain.combi.a1 affects compound 1,  esc.constrain.combi.a2 affects compound 2. instance, possible activate restriction next larger dose level first compound, still use escalation step second compound. cohort.size, cohort.size.mono1., cohort.size.mono2., cohort.size.combi.Optional positive integer vectors specify available cohort sizes simulated cohorts. global variant, cohort.size, defaults 3 (.e., cohorts contain 3 patients), remaining trial-specific parameters default value cohort.size. particular, trials shall use cohort sizes, value cohort.size needs defined, trial-specific variants can used express specific trial shall deviate global parameter. cohort.size can either single value (cohorts use size) vector integers give available cohort sizes. latter case, simulated cohort sizes drawn random possible cohort sizes using probability cohort size specified cohort.prob. , trial-specific variant, cohort.size.[...], affect corresponding trial. cohort.size.mono1.b, cohort.size.mono2.b, cohort.size.combi.b cohort.size.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. cohort.prob, cohort.prob.mono1., cohort.prob.mono2., cohort.prob.combi.Optional positive numeric vectors values 0 1 specify probability available cohort sizes corresponding argument cohort.size.[...]. global variant, cohort.prob, defaults NULL, remaining trial-specific parameters default value cohort.prob. parameter NULL trial, function assign probability entry cohort.size, .e., cohort size chosen uniformly random provided possible cohort sizes. trials shall use probabilities selecting cohort size, value cohort.prob needs defined, trial-specific variants can used express specific trial shall deviate global parameter. arguments cohort.prob.[...] must NULL vector length argument cohort.size.[...], lengths contents may differ across different trials/suffixes. cohort.prob.mono1.b, cohort.prob.mono2.b, cohort.prob.combi.b cohort.prob.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. max.n, max.n.mono1., max.n.mono2., max.n.combi.Optional positive integer values specify maximum number patients enrolled simulated trials. simulated number patients trial equals surpasses specified number max.n.[...] stopped prematurely determined MTD yet, simulated trial stopped without declaring MTD due reaching maximum sample size. global variant parameter, max.n, defaults 42 (.e., MTD must reached 14 cohorts default values cohort.size cohort.prob used). trial-specific parameters, max.n.[...], default global value max.n need adjusted corresponding trial shall deviate global value. max.n.mono1.b, max.n.mono2.b, max.n.combi.b max.n.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. mtd.decision, mtd.decision.mono1., mtd.decision.mono2., mtd.decision.combi.Optional named lists specify rules MTD selection. determination MTD may occur independently simulated trial soon conditions specified corresponding mtd.decision[...] met. list must five named entries, namely, target.prob, pat..mtd, min.pat, min.dlt, rule. names list entries case sensitive. actual MTD selection, function always first demand current dose level current trial recommended , .e. also recommended dose next cohort trial (-called stabilization criterion). case, conditions specified corresponding mtd.decision[...] checked. conditions also satisfied, function declare current dose trial MTD simulate cohorts trial. entries single numerical values following specifications interpretations. mtd.decision[...]$rule Integer, can 1 2 (latter default). Specifies remaining entries mtd.decision[...] used mandatory conditions MTD selection. rules, two conditions demanded necessary conditions, one remaining two conditions must hold. precise specifications : mtd.decision[...]$rule=1 conditions posed entries mtd.decision[...]$pat..mtd mtd.decision[...]$min.dlt mandatory, one conditions posed mtd.decision[...]$min.pat mtd.decision[...]$target.prob must hold. mtd.decision[...]$rule=2 conditions mtd.decision[...]$min.pat mtd.decision[...]$min.dlt mandatory, one conditions posed mtd.decision[...]$pat..mtd mtd.decision[...]$target.prob must hold. mtd.decision[...]$min.pat Non-negative integer, defaults 12. Specifies minimum number patients need enrolled trial MTD can declared. mtd.decision[...]$pat..mtd Non-negative integer, defaults 6. Specifies minimum number patients need treated current dose (.e., current candidate MTD determination) MTD can declared. mtd.decision[...]$min.dlt Non-negative integer, defaults 1. Specifies minimum number DLTs need observed trial MTD can declared. mtd.decision[...]$target.prob Non-negative real number strictly smaller 1, defaults 0.5. Specifies minimum probability true DLT rate target interval needs reached dose declared MTD. Note condition always one two optional conditions, .e., case first rule, condition need hold sufficiently many patients enrolled total, case second rule, condition need hold sufficiently many patients enrolled MTD. , global parameter mtd.decision can used select rule used simulated trials. trial-specific parameters, mtd.decision.[...], default global value can adjusted use different, trial-specific decision rules trials. mtd.decision.mono1.b, mtd.decision.mono2.b, mtd.decision.combi.b mtd.decision.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. mtd.enforce, mtd.enforce.mono1., mtd.enforce.mono2., mtd.enforce.combi.Optional logicals, default FALSE. parameters indicate whether declaration MTD enforced maximum number patients reached trial stopped yet. , parameter mtd.enforce.[...] specific trial TRUE, function declare next recommended dose MTD maximum number patients (max.n.[...]) reached (provided trial stopped early found MTD reaching maximum sample size). particular, trials counted belong category trials reached maximum sample size without declaring MTD. , note value mtd.decision.[...]$min can set value greater maximum sample size, result declaring MTD maximum sample size reached, earlier points (condition minimal patient number fulfilled ). , global variant parameter, namely mtd.enforce, can used set option trials . set escalation rule specific trial, use trial-specific variants mtd.enforce.[...] corresponding suffix. mtd.enforce.mono1.b, mtd.enforce.mono2.b, mtd.enforce.combi.b mtd.enforce.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. backfill.mono1., backfill.mono2., backfill.combi.Optional logicals, indicating whether back-fill cohorts simulated trial. backfill.mono1.b, backfill.mono2.b, backfill.combi.b backfill.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. backfill.size, backfill.size.mono1., backfill.size.mono2., backfill.size.combi.Optional numericals, provide size simulated back-fill cohorts. Interpreted fashion cohort.size. backfill.prob, backfill.prob.mono1., backfill.prob.mono2., backfill.prob.combi.Optional numericals, provide probabilities multiple possible back-fill cohort sizes given. Interpreted fashion cohort.prob. backfill.size.mono1.b, backfill.size.mono2.b, backfill.size.combi.b backfill.size.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. backfill.prob.mono1.b, backfill.prob.mono2.b, backfill.prob.combi.b backfill.prob.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. backfill.start.mono1., backfill.start.mono2., backfill.start.combi.a1, backfill.start.combi.a2 Optional numericals. Specify first dose back-fill cohorts enrolled. provided, lowest available dose assumed starting point back-fill cohorts respective trial. backfill.start.mono1.b, backfill.start.mono2.b, backfill.start.combi.b1, backfill.start.combi.b2 backfill.start.[...].([...] mono1, mono2, combi) second potentially simulated trial (suffix .b) respective trial type. n.studies Positive integer specifies number studies simulated, defaults 1. Due long simulation time, recommended first try lower numbers obtain estimation run-time larger numbers studies. Typically, 1000 studies recommended obtain acceptably accurate simulation results. seed Optional positive integer specified seed used simulation. default sample.int(.Machine$integer.max, 1). Note reproducibility can obtained function executed exactly computing architecture, using identical software versions (e.g. compiler, Stan, R), input specifications. due internal use rstan-package MCMC sampling, reproducible restrictions (refer Stan reference manual rstan-package's homepage detail). chains Optional positive integer specifies number Markov chains used MCMC sampling, defaults 4. parameter given method rstan::sampling() package rstan-package. iter Optional positive integer specifies total number iterations per chain used MCMC sampling, defaults 6000. parameter given method rstan::sampling() package rstan-package. aware first warmup iterations among iter-many samples discarded. function enforces iter least 2000, iter larger equal warmup + 1000 (ensure least 1000 samples chain kept). warmup Optional positive integer specifies number iterations per chain discarded total number iterations, iter. Defaults 1000. parameter given method rstan::sampling() package rstan-package. function enforces warmup least 1000, iter larger equal warmup + 1000 (ensure least 1000 samples chain kept). adapt_delta Optional numerical must least 0.6 smaller 1, defaults 0.8. parameter given argument control rstan::sampling() method package rstan-package. Translates target Metropolis acceptance probability Hamiltonian Monte Carlo, respectively NUTS. Can used influence stepsize Stan uses leapfrog steps NUTS algorithm. See rstan::sampling(), rstan-package details reading. Note: Larger values default can used reduce number Stan warnings \"divergent transition\", slow sampling. function permit set adapt_delta values 0.6 (rstan-package default). max_treedepth Optional integer must least 10, defaults 15. parameter given argument control rstan::sampling() method package rstan-package. parameter NUTS algorithm. Roughly speaking, NUTS constructs search tree generating new proposal, stopping criterion (NUTS criterion) satisfied , alternatively, maximum depth search tree reached (avoid endless looping). argument max_treedepth allows control latter. maximum treedepth also automatically constrain maximum number leapfrog steps, therefore 10. See also rstan::sampling() details max_treedepth. Note: default maximum treedepth 15 usually reached sampling (never tests, although excluded general), otherwise Stan print warning. case, recommended increase value. refresh Optional integer, defaults 0. parameter given rstan::sampling() method package rstan-package controls amount intermediate output calls rstan::sampling(). affects non-parallelized simulations (otherwise affects output worker, discarded anyway). positive value given, number interpreted number samples intermediate progress reported MCMC sampling (e.g., set 1000, Stan prints progress report every 1000 samples). refresh 0 (default) negative, output printed sampling. Changing value refresh affect results simulation, although recommended change positive number: function can lead many calls rstan::sampling() (multiple thousand 1000 trials simulated), intermediate output helpful interpretable settings anyway. file.name Optional character string provides name potential output files. output written file.name path specified, case, outputs returned R. given, excel sheet simulation results written disk. path Optional character string specifies path output directory. output written file.name path specified, case, outputs returned R. given path points directory, excel sheet excel sheet contains simulation results written specified location. monitor.path Optional character string specifies path additional output directory monitoring simulation progress. precisely, monitor.path NULL (default) valid file.name given, function write output file completed trial monitor.path (provided specifies writable directory). can used monitor progress (parallelized) simulations, may take multiple hours simulate. working.path Optional character string specifies path directory temporary results. directory used save MCCM results given data scenario unique (hashed) file names, allows re-loading MCMC runs whenever data scenario occurs later trial. also works parallelized simulations. File names temporary results use given file.name concatenated \"_tmp\" prefix. modify files manually avoid errors. avoid reloading results previous simulations (potentially different MCMC settings priors), function check files whose name contains file.name \"_tmp\" directory specified working.path simulation. files detected, error thrown. allow function automatically delete files working.path simulation, consider using argument clean.working.path. clean.working.path Optional logical, defaults FALSE. Indicates whether function allowed delete existing files contain file.name \"_tmp\" name directory specified working.path. TRUE, temporary files automatically removed working directory simulation. FALSE, function check file names initially throw error files found. output.sim.config Optional logical specifies whether input parameters call sim_jointBLRM() added output list (, activated, output files written disk). Defaults TRUE. can used save e.g. seed, dose-toxicity scenarios, priors simulation allow double-checking configuration simulation later point time.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_jointBLRM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate dose-finding trials — sim_jointBLRM","text":"List contains number metrics summarize results simulation simulated trial, , depending specification, additional list entries save given input specification. default, following list entries generated simulated trial ([...] corresponding suffix trial): ...$'results [...]' Overview number MTDs per dosing interval (, target, ), number trials stopped without finding MTD, either due stopping rule (EWOC-based escalation used) due reaching maximal patient number. ...$'summary [...]' Summary statistics (mean, median, min, max, 2.5% 97.5% quantile) number patients, patients per dosing interval, DLTs, DLTs per dosing interval. ...$'MTDs [...]' Number MTDs per dose level assumed DLT rates. ...$'#pat [...]' Mean, median, minimum maximum number patients enrolled dose level. Additionally, output.sim.config active, list include following entries: ...$'historical.data' included historical data included simulations. Contains specified cohorts historical data. ...$'prior' prior distribution hyper-parameters used BLRM. ...$'specifications' simulation specifications. Includes e. g. reference doses, decision rules, escalation steps, seed. ...$'Stan options' Options given Stan, number MCMC iterations chains.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_jointBLRM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate dose-finding trials — sim_jointBLRM","text":"joint BLRM defined according (Neuenschwander et al., 2014 2016). allows perform Bayesian logistic regression estimate dose-toxicity relationship two different monotherapies combination therapy compounds joint model, includes hierarchical prior robust borrowing across trials. Refer documentation scenario_jointBLRM() detailed model description.","code":""},{"path":"https://Boehringer-Ingelheim.github.io/decider/reference/sim_jointBLRM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate dose-finding trials — sim_jointBLRM","text":"Stan Development Team (2020). RStan: R interface Stan. R package version 2.21.2. https://mc-stan.org. Neuenschwander, B., Branson, M., & Gsponer, T. (2008). Critical aspects Bayesian approach phase cancer trials. Statistics medicine, 27(13), 2420-2439, doi:10.1002/sim.3230. Neuenschwander, B., Matano, ., Tang, Z., Roychoudhury, S., Wandel, S., & Bailey, S. (2014). Bayesian Industry Approach Phase Combination Trials Oncology. : Zhao. W & Yang, H. (editors). Statistical methods drug combination studies. Chapman Hall/CRC, 95-135, doi:10.1201/b17965. Neuenschwander, B., Roychoudhury, S., & Schmidli, H. (2016). use co-data clinical trials. Statistics Biopharmaceutical Research, 8(3), 345-354, doi:10.1080/19466315.2016.1174149. Babb, J., Rogatko, ., & Zacks, S. (1998). Cancer phase clinical trials: Efficient dose escalation overdose control. Statistics medicine 17(10), 1103-1120. Zhou, H.,  Yuan, Y., & Nie, L. (2018). Accuracy, safety, reliability novel phase designs. Clinical Cancer Research, 24(21), 5483-5484 <doi: 10.1158/1078-0432.ccr-18-0168>.","code":""},{"path":[]},{"path":"https://Boehringer-Ingelheim.github.io/decider/news/index.html","id":"decider-0009011","dir":"Changelog","previous_headings":"","what":"decider 0.0.0.9011","title":"decider 0.0.0.9011","text":"first version decider package github. Functions scenario evaluation simulation hierarchical/joint BLRM two-drug combination therapy provided, allowing particular trial designs consisting concurrent monotherapy combination therapy escalation, including potentially data historical trials. main functions : scenario_jointBLRM() sim_jointBLRM. functions second version additionally allows use binary covariate.","code":""}]
